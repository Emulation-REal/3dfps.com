<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>3D FPS Shooter Multiplayer with Mods</title>
<style>
  body {
    margin: 0; overflow: hidden; font-family: Arial, sans-serif; background: #111;
  }
  #modMenu {
    position: fixed;
    top: 50px; right: 50px;
    background: rgba(0,0,0,0.7);
    color: white;
    padding: 10px;
    font-size: 14px;
    border-radius: 6px;
    display: none;
    user-select: none;
    z-index: 1000;
  }
  #modMenu label {
    display: flex;
    align-items: center;
    margin-bottom: 6px;
    cursor: pointer;
  }
  #modMenu label input {
    margin-right: 6px;
  }
  #crosshair {
    position: fixed;
    top: 50%; left: 50%;
    width: 12px; height: 12px;
    margin-left: -6px; margin-top: -6px;
    pointer-events: none;
    z-index: 999;
  }
  #crosshair div {
    position: absolute;
    background: white;
  }
  #crosshair .hor {
    top: 50%; left: 0;
    width: 100%; height: 2px;
    margin-top: -1px;
  }
  #crosshair .ver {
    left: 50%; top: 0;
    width: 2px; height: 100%;
    margin-left: -1px;
  }
  .nametag {
    color: white;
    font-weight: bold;
    font-size: 12px;
    text-align: center;
    user-select: none;
    pointer-events: none;
    text-shadow:
      -1px -1px 0 #000,
      1px -1px 0 #000,
      -1px 1px 0 #000,
      1px 1px 0 #000;
  }
  .healthbar {
    width: 40px;
    height: 6px;
    background: #333;
    border-radius: 3px;
    overflow: hidden;
    margin-top: 2px;
    box-shadow: 0 0 4px rgba(0,0,0,0.7);
  }
  .healthbar-inner {
    height: 100%;
    background: limegreen;
    transition: width 0.2s ease-out;
  }
</style>
</head>
<body>
<div id="modMenu">
  <label><input type="checkbox" id="modEsp" /> ESP (Boxes + Name + Health)</label>
  <label><input type="checkbox" id="modTracers" /> Tracers</label>
  <label><input type="checkbox" id="modAimbot" /> Aimbot (Hold Right Mouse)</label>
  <label><input type="checkbox" id="modNoClip" /> No-Clip (Walk through walls)</label>
  <label><input type="checkbox" id="modSpeed" /> Speed Hack</label>
  <small>Press ";" to toggle menu and unlock cursor</small>
</div>

<div id="crosshair">
  <div class="hor"></div>
  <div class="ver"></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.125.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.125.2/examples/js/controls/PointerLockControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/netplayjs@0.1.2/dist/netplay.min.js"></script>

<script>
(() => {
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Lighting
  const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1);
  hemiLight.position.set(0, 200, 0);
  scene.add(hemiLight);
  const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
  dirLight.position.set(0, 200, 100);
  scene.add(dirLight);

  // Floor
  const floorMat = new THREE.MeshStandardMaterial({color: 0x333333});
  const floorGeo = new THREE.PlaneGeometry(200, 200);
  const floor = new THREE.Mesh(floorGeo, floorMat);
  floor.rotation.x = -Math.PI / 2;
  floor.receiveShadow = true;
  scene.add(floor);

  // Obstacles (taller, more)
  const obstacles = [];
  const obstacleMat = new THREE.MeshStandardMaterial({color: 0x666666});
  const obstacleGeo = new THREE.BoxGeometry(3, 5, 1.5); // tall jersey barriers

  const obstaclePositions = [
    [-10, 2.5, -10],
    [5, 2.5, -15],
    [15, 2.5, 5],
    [-15, 2.5, 15],
    [0, 2.5, 0],
    [8, 2.5, 8],
    [-8, 2.5, 8],
    [-8, 2.5, -8],
    [8, 2.5, -8],
  ];

  for (const pos of obstaclePositions) {
    const obs = new THREE.Mesh(obstacleGeo, obstacleMat);
    obs.position.set(...pos);
    obs.castShadow = true;
    obs.receiveShadow = true;
    scene.add(obs);
    obstacles.push(obs);
  }

  // Player Setup
  const controls = new THREE.PointerLockControls(camera, document.body);
  scene.add(controls.getObject());
  camera.position.set(0, 1.6, 5);

  const velocity = new THREE.Vector3();
  const direction = new THREE.Vector3();

  // Movement state
  const move = {forward:false, backward:false, left:false, right:false};
  let canJump = false;
  let prevTime = performance.now();

  // Health and shooting
  let playerHealth = 100;
  let shootCooldown = 0;

  // Crosshair & mod menu toggle
  const modMenu = document.getElementById('modMenu');
  let modMenuOpen = false;

  window.addEventListener('keydown', (e) => {
    if (e.code === 'KeyW') move.forward = true;
    if (e.code === 'KeyS') move.backward = true;
    if (e.code === 'KeyA') move.left = true;
    if (e.code === 'KeyD') move.right = true;
    if (e.code === 'Space' && canJump) {
      velocity.y += 7;
      canJump = false;
    }
    if (e.key === ';') {
      modMenuOpen = !modMenuOpen;
      if (modMenuOpen) {
        modMenu.style.display = 'block';
        controls.unlock();
      } else {
        modMenu.style.display = 'none';
        controls.lock();
      }
    }
  });
  window.addEventListener('keyup', (e) => {
    if (e.code === 'KeyW') move.forward = false;
    if (e.code === 'KeyS') move.backward = false;
    if (e.code === 'KeyA') move.left = false;
    if (e.code === 'KeyD') move.right = false;
  });

  // Lock pointer on click unless mod menu open
  document.body.addEventListener('click', () => {
    if (!modMenuOpen) controls.lock();
  });

  // Basic box for player collision
  const playerBox = new THREE.Box3();
  const tempBox = new THREE.Box3();

  // Enemies
  const enemyGeometry = new THREE.BoxGeometry(1, 2, 1);
  const enemyMaterial = new THREE.MeshStandardMaterial({color: 0xff0000});
  const enemies = [];

  const enemyCount = 15; // more enemies

  // Enemy class with health and name tag
  class Enemy {
    constructor(id, isPlayer = false) {
      this.id = id;
      this.isPlayer = isPlayer;
      this.health = 100;
      this.mesh = new THREE.Mesh(enemyGeometry, enemyMaterial.clone());
      this.mesh.position.set((Math.random()-0.5)*50, 1, (Math.random()-0.5)*50);
      this.mesh.castShadow = true;

      // Name tag container
      this.nameTagDiv = document.createElement('div');
      this.nameTagDiv.className = 'nametag';
      this.nameTagDiv.textContent = isPlayer ? `Player ${id}` : `Enemy ${id}`;
      document.body.appendChild(this.nameTagDiv);

      // Health bar
      this.healthBarDiv = document.createElement('div');
      this.healthBarDiv.className = 'healthbar';
      this.healthInnerDiv = document.createElement('div');
      this.healthInnerDiv.className = 'healthbar-inner';
      this.healthBarDiv.appendChild(this.healthInnerDiv);
      document.body.appendChild(this.healthBarDiv);

      scene.add(this.mesh);
    }

    updateNameTag(cam) {
      const pos = this.mesh.position.clone();
      pos.y += 2.5;
      const vector = pos.project(cam);
      const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
      const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;

      this.nameTagDiv.style.transform = `translate(-50%, -50%) translate(${x}px,${y}px)`;
      this.healthBarDiv.style.transform = `translate(-50%, -50%) translate(${x}px,${y + 15}px)`;
    }

    updateHealthBar() {
      this.healthInnerDiv.style.width = `${this.health}%`;
      if (this.health > 60) this.healthInnerDiv.style.background = 'limegreen';
      else if (this.health > 30) this.healthInnerDiv.style.background = 'orange';
      else this.healthInnerDiv.style.background = 'red';
    }

    dispose() {
      scene.remove(this.mesh);
      this.nameTagDiv.remove();
      this.healthBarDiv.remove();
    }
  }

  // Create initial enemies
  for (let i=0; i<enemyCount; i++) {
    enemies.push(new Enemy(i));
  }

  // Multiplayer players map: id -> Enemy instance
  const players = new Map();

  // Mods
  const modEsp = document.getElementById('modEsp');
  const modTracers = document.getElementById('modTracers');
  const modAimbot = document.getElementById('modAimbot');
  const modNoClip = document.getElementById('modNoClip');
  const modSpeed = document.getElementById('modSpeed');

  // Tracers group
  const tracerMaterial = new THREE.LineBasicMaterial({color: 0x00ffff});
  const tracers = new THREE.Group();
  scene.add(tracers);

  // For aimbot target selection
  function getClosestEnemyToCrosshair() {
    let closest = null;
    let closestDist = Infinity;
    enemies.forEach(enemy => {
      if (enemy.health <= 0) return;
      const enemyPos = enemy.mesh.position.clone();
      const screenPos = enemyPos.project(camera);
      // Distance from center (0,0)
      const dist = Math.sqrt(screenPos.x*screenPos.x + screenPos.y*screenPos.y);
      if (dist < closestDist) {
        closestDist = dist;
        closest = enemy;
      }
    });
    return closest;
  }

  // Respawn enemy at random pos
  function respawnEnemy(enemy) {
    enemy.health = 100;
    enemy.mesh.position.set((Math.random()-0.5)*50, 1, (Math.random()-0.5)*50);
  }

  // Player shooting and bullets
  const bullets = [];
  const bulletSpeed = 50;
  const bulletGeo = new THREE.SphereGeometry(0.1, 8, 8);
  const bulletMat = new THREE.MeshBasicMaterial({color: 0xffff00});

  function shoot() {
    if (shootCooldown > 0) return;
    shootCooldown = 0.3;
    const bullet = new THREE.Mesh(bulletGeo, bulletMat);
    bullet.position.copy(camera.position);
    const forward = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
    bullet.userData.velocity = forward.multiplyScalar(bulletSpeed);
    bullets.push(bullet);
    scene.add(bullet);
  }

  // Collision detection helper
  function boxIntersectsBox(box1, box2) {
    return box1.intersectsBox(box2);
  }

  // Player collision box size
  const playerHeight = 1.6;
  const playerRadius = 0.5;

  // Update loop
  function animate() {
    requestAnimationFrame(animate);

    const time = performance.now();
    const delta = (time - prevTime) / 1000;
    prevTime = time;

    // Mod speed hack
    const baseSpeed = 10;
    let speed = baseSpeed;
    if (modSpeed.checked) speed = baseSpeed * 2.5;

    // Movement direction
    direction.z = Number(move.forward) - Number(move.backward);
    direction.x = Number(move.right) - Number(move.left);
    direction.normalize();

    // Velocity calculations
    if (!modNoClip.checked) {
      // Apply gravity
      velocity.y -= 9.8 * delta;
    }

    // Move player
    if (controls.isLocked === true) {
      // Apply speed
      velocity.x -= velocity.x * 10.0 * delta;
      velocity.z -= velocity.z * 10.0 * delta;

      velocity.x += direction.x * speed * delta;
      velocity.z += direction.z * speed * delta;

      controls.moveRight(velocity.x * delta);
      controls.moveForward(velocity.z * delta);

      controls.getObject().position.y += velocity.y * delta;

      // Floor collision
      if (controls.getObject().position.y < playerHeight) {
        velocity.y = 0;
        controls.getObject().position.y = playerHeight;
        canJump = true;
      }

      // Obstacle collisions if no-clip off
      if (!modNoClip.checked) {
        const playerPos = controls.getObject().position;

        // Player bounding box (approximate as box centered at player's position)
        const playerBoxMin = new THREE.Vector3(playerPos.x - playerRadius, playerPos.y - playerHeight, playerPos.z - playerRadius);
        const playerBoxMax = new THREE.Vector3(playerPos.x + playerRadius, playerPos.y, playerPos.z + playerRadius);
        playerBox.set(playerBoxMin, playerBoxMax);

        for (const obs of obstacles) {
          const obsBox = new THREE.Box3().setFromObject(obs);
          if (playerBox.intersectsBox(obsBox)) {
            // Undo movement
            controls.moveRight(-velocity.x * delta);
            controls.moveForward(-velocity.z * delta);
            break;
          }
        }
      }
    }

    // Update bullets
    for (let i=bullets.length-1; i>=0; i--) {
      const b = bullets[i];
      b.position.addScaledVector(b.userData.velocity, delta);

      // Remove bullets too far away
      if (b.position.distanceTo(camera.position) > 100) {
        scene.remove(b);
        bullets.splice(i,1);
        continue;
      }

      // Check bullet collisions with enemies
      const bulletBox = new THREE.Box3().setFromCenterAndSize(b.position, new THREE.Vector3(0.2,0.2,0.2));
      for (const enemy of enemies) {
        if (enemy.health <= 0) continue;
        const enemyBox = new THREE.Box3().setFromObject(enemy.mesh);
        if (bulletBox.intersectsBox(enemyBox)) {
          enemy.health -= 34;
          enemy.updateHealthBar();
          if (enemy.health <= 0) {
            // Respawn after short delay
            setTimeout(() => respawnEnemy(enemy), 5000);
          }
          scene.remove(b);
          bullets.splice(i, 1);
          break;
        }
      }
    }

    // Enemy AI follow player
    for (const enemy of enemies) {
      if (enemy.health <= 0) continue;
      const pos = enemy.mesh.position;
      const playerPos = controls.getObject().position;

      // Direction to player (ignore y)
      const dir = new THREE.Vector3(playerPos.x - pos.x, 0, playerPos.z - pos.z);
      if (dir.length() > 0.01) {
        dir.normalize();
        enemy.mesh.position.addScaledVector(dir, delta * 2.5);
      }

      // Check collision with player - damage health
      const enemyBox = new THREE.Box3().setFromObject(enemy.mesh);

      const playerBoxMin = new THREE.Vector3(playerPos.x - playerRadius, playerPos.y - playerHeight, playerPos.z - playerRadius);
      const playerBoxMax = new THREE.Vector3(playerPos.x + playerRadius, playerPos.y, playerPos.z + playerRadius);
      playerBox.set(playerBoxMin, playerBoxMax);

      if (playerBox.intersectsBox(enemyBox)) {
        playerHealth -= 10 * delta;
        if (playerHealth < 0) playerHealth = 0;
      }
    }

    // Mods: ESP boxes + name tags + health bars
    enemies.forEach(enemy => {
      enemy.nameTagDiv.style.display = modEsp.checked ? 'block' : 'none';
      enemy.healthBarDiv.style.display = modEsp.checked ? 'block' : 'none';

      if (modEsp.checked && enemy.health > 0) {
        enemy.updateNameTag(camera);
        enemy.updateHealthBar();
      }
    });

    // Tracers
    tracers.clear();
    if (modTracers.checked) {
      const material = new THREE.LineBasicMaterial({color: 0x00ffff});
      enemies.forEach(enemy => {
        if (enemy.health <= 0) return;
        const points = [];
        points.push(camera.position.clone());
        const pos = enemy.mesh.position.clone();
        pos.y += 1; // aim near head
        points.push(pos);
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(geometry, material);
        tracers.add(line);
      });
    }

    // Aimbot - if enabled and right mouse button held
    if (modAimbot.checked && rightMouseDown) {
      const target = getClosestEnemyToCrosshair();
      if (target && target.health > 0) {
        const targetPos = target.mesh.position.clone();
        targetPos.y += 1.2; // aim near head
        const dir = targetPos.clone().sub(camera.position).normalize();

        // Smoothly rotate camera to target direction
        const currentDir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
        const lerpDir = currentDir.lerp(dir, 0.15).normalize();

        // Convert direction back to rotation
        const pitch = Math.asin(lerpDir.y);
        const yaw = Math.atan2(lerpDir.x, -lerpDir.z);

        controls.getObject().rotation.y = yaw;
        camera.rotation.x = pitch;

        // Auto-shoot
        shoot();
      }
    }

    // Render
    renderer.render(scene, camera);
  }

  // Mouse events
  let rightMouseDown = false;
  window.addEventListener('mousedown', e => {
    if (e.button === 2) rightMouseDown = true;
    if (e.button === 0) shoot();
  });
  window.addEventListener('mouseup', e => {
    if (e.button === 2) rightMouseDown = false;
  });

  // Prevent context menu on right click
  window.addEventListener('contextmenu', e => e.preventDefault());

  // On window resize
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  // Start animation loop
  animate();

  // Lock pointer on start for gameplay
  controls.lock();

  // Multiplayer with NetplayJS
  const np = new Netplay({
    host: 'wss://emulation12.netplay.live',
    room: 'emu-fps',
    playerName: `Player${Math.floor(Math.random()*1000)}`,
  });

  np.on('connect', () => {
    console.log('Connected to multiplayer server');
  });

  // Track other players, map of id -> Enemy
  np.on('stateUpdate', state => {
    // state example: {players: {id: {pos: [x,y,z], rot: [x,y,z]}, ...}}
    const playersState = state.players || {};
    // Remove disconnected players
    for (const [id, enemy] of players.entries()) {
      if (!playersState[id]) {
        enemy.dispose();
        players.delete(id);
      }
    }
    // Update or add players
    for (const id in playersState) {
      if (id === np.id) continue; // skip self
      const pdata = playersState[id];
      if (!players.has(id)) {
        // Add new player as enemy box
        const e = new Enemy(`MP${id}`, true);
        players.set(id, e);
      }
      const e = players.get(id);
      e.mesh.position.set(pdata.pos[0], pdata.pos[1], pdata.pos[2]);
      e.mesh.rotation.set(pdata.rot[0], pdata.rot[1], pdata.rot[2]);
      e.health = pdata.health || 100;
      e.updateHealthBar();

      e.nameTagDiv.style.display = modEsp.checked ? 'block' : 'none';
      e.healthBarDiv.style.display = modEsp.checked ? 'block' : 'none';
      if (modEsp.checked) e.updateNameTag(camera);
    }
  });

  // Send player state to server
  function sendPlayerState() {
    if (!np.connected) return;
    const pos = controls.getObject().position;
    const rot = controls.getObject().rotation;
    np.sendState({
      pos: [pos.x, pos.y, pos.z],
      rot: [rot.x, rot.y, rot.z],
      health: playerHealth,
    });
  }

  setInterval(sendPlayerState, 50);

})();
</script>
</body>
</html>

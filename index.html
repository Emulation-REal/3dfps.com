<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>3D Multiplayer FPS with Mods</title>
<style>
  body, html {
    margin: 0; padding: 0; overflow: hidden; background: #222;
    font-family: Arial, sans-serif;
    user-select: none;
  }
  canvas { display: block; }

  #overlay {
    position: absolute; top: 0; left: 0; pointer-events: none;
  }

  #modMenu {
    position: absolute;
    top: 10px; right: 10px;
    background: rgba(0,0,0,0.7);
    padding: 10px;
    color: white;
    font-size: 14px;
    border-radius: 6px;
    width: 200px;
    user-select: none;
    z-index: 10;
  }
  #modMenu h2 {
    margin: 0 0 10px 0; font-size: 18px; border-bottom: 1px solid #555;
    padding-bottom: 5px;
  }
  #modMenu label {
    display: block;
    margin-bottom: 8px;
    cursor: pointer;
  }

  #instructions {
    position: absolute;
    bottom: 10px;
    left: 10px;
    color: white;
    font-size: 14px;
    background: rgba(0,0,0,0.5);
    padding: 8px;
    border-radius: 6px;
  }
</style>
</head>
<body>

<div id="modMenu">
  <h2>Mod Menu</h2>
  <label><input type="checkbox" id="espToggle" /> ESP (Boxes)</label>
  <label><input type="checkbox" id="tracerToggle" /> Tracers</label>
  <label><input type="checkbox" id="aimbotToggle" /> Aimbot (Hold RMB)</label>
</div>

<div id="instructions">
  WASD: Move | SPACE: Jump | RMB: Hold for Aimbot
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/examples/js/controls/PointerLockControls.js"></script>
<script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>

<script>
(() => {
  // ======= Setup Three.js scene =======
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x444444);

  const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0, 1.8, 5);

  // Renderer
  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Overlay canvas for ESP/tracers
  const overlay = document.createElement('canvas');
  overlay.id = 'overlay';
  overlay.width = window.innerWidth;
  overlay.height = window.innerHeight;
  document.body.appendChild(overlay);
  const ctx = overlay.getContext('2d');

  // Resize handling
  window.addEventListener('resize', () => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    overlay.width = window.innerWidth;
    overlay.height = window.innerHeight;
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
  });

  // ======= Lighting =======
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
  scene.add(ambientLight);
  const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
  dirLight.position.set(5, 10, 7);
  scene.add(dirLight);

  // ======= Ground & Map =======
  const groundGeometry = new THREE.PlaneGeometry(40, 40);
  const groundMaterial = new THREE.MeshPhongMaterial({color: 0x333333});
  const ground = new THREE.Mesh(groundGeometry, groundMaterial);
  ground.rotation.x = -Math.PI/2;
  ground.receiveShadow = true;
  scene.add(ground);

  // Obstacles - collidable boxes
  const obstacles = [];
  const obstacleGeometry = new THREE.BoxGeometry(2, 2, 2);
  const obstacleMaterial = new THREE.MeshPhongMaterial({color: 0x6666ff});
  const obstaclePositions = [
    [4, 1, 0],
    [-5, 1, -3],
    [0, 1, -6],
    [-3, 1, 5],
    [6, 1, 6]
  ];
  for(let pos of obstaclePositions) {
    const box = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
    box.position.set(pos[0], pos[1], pos[2]);
    box.castShadow = true;
    scene.add(box);
    obstacles.push(box);
  }

  // ======= Player Class =======
  class Player {
    constructor(id, isLocal=false) {
      this.id = id;
      this.isLocal = isLocal;

      this.height = 1.8;
      this.speed = 5;
      this.jumpSpeed = 6;
      this.gravity = -15;
      this.velocityY = 0;

      // Position and size for collision
      this.position = new THREE.Vector3(0, this.height, 0);
      this.boundingBox = new THREE.Box3();

      // Visual model
      const bodyGeometry = new THREE.BoxGeometry(0.6, this.height, 0.6);
      const bodyMaterial = new THREE.MeshPhongMaterial({color: isLocal ? 0x22ff22 : 0xff2222});
      this.mesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
      this.mesh.castShadow = true;
      scene.add(this.mesh);

      // For aimbot targeting
      this.targetPoint = new THREE.Vector3();

      if(isLocal) {
        // Controls
        this.controls = new THREE.PointerLockControls(camera, document.body);
        this.canJump = false;
        this.moveForward = false;
        this.moveBackward = false;
        this.moveLeft = false;
        this.moveRight = false;

        // Setup controls
        document.body.addEventListener('click', () => {
          this.controls.lock();
        });

        this.controls.addEventListener('lock', () => {
          // console.log("Pointer locked");
        });
        this.controls.addEventListener('unlock', () => {
          // console.log("Pointer unlocked");
        });

        // Movement keys
        const onKeyDown = (event) => {
          switch(event.code) {
            case 'ArrowUp':
            case 'KeyW':
              this.moveForward = true;
              break;
            case 'ArrowLeft':
            case 'KeyA':
              this.moveLeft = true;
              break;
            case 'ArrowDown':
            case 'KeyS':
              this.moveBackward = true;
              break;
            case 'ArrowRight':
            case 'KeyD':
              this.moveRight = true;
              break;
            case 'Space':
              if(this.canJump) {
                this.velocityY = this.jumpSpeed;
                this.canJump = false;
              }
              break;
          }
        };

        const onKeyUp = (event) => {
          switch(event.code) {
            case 'ArrowUp':
            case 'KeyW':
              this.moveForward = false;
              break;
            case 'ArrowLeft':
            case 'KeyA':
              this.moveLeft = false;
              break;
            case 'ArrowDown':
            case 'KeyS':
              this.moveBackward = false;
              break;
            case 'ArrowRight':
            case 'KeyD':
              this.moveRight = false;
              break;
          }
        };

        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);
      }
    }

    update(delta) {
      if(this.isLocal) {
        const dir = new THREE.Vector3();

        if(this.moveForward) dir.z -= 1;
        if(this.moveBackward) dir.z += 1;
        if(this.moveLeft) dir.x -= 1;
        if(this.moveRight) dir.x += 1;

        dir.normalize();

        // Move direction relative to camera rotation Y
        const angle = this.controls.getObject().rotation.y;
        const sin = Math.sin(angle);
        const cos = Math.cos(angle);
        const dx = dir.x * cos - dir.z * sin;
        const dz = dir.z * cos + dir.x * sin;

        this.position.x += dx * this.speed * delta;
        this.position.z += dz * this.speed * delta;

        // Gravity and jumping
        this.velocityY += this.gravity * delta;
        this.position.y += this.velocityY * delta;

        // Collisions with ground and obstacles
        if(this.position.y < this.height) {
          this.position.y = this.height;
          this.velocityY = 0;
          this.canJump = true;
        }

        // Collision with obstacles
        for(let obs of obstacles) {
          if(this.boxIntersect(this.position, obs)) {
            // Simple collision push back (undo last step)
            this.position.x -= dx * this.speed * delta;
            this.position.z -= dz * this.speed * delta;
          }
        }

        // Update camera position
        this.controls.getObject().position.copy(this.position);

        // Update mesh position
        this.mesh.position.copy(this.position);
      } else {
        // For other players: just update mesh position from synced data
        this.mesh.position.copy(this.position);
      }

      // Update bounding box for ESP & collision
      this.boundingBox.setFromCenterAndSize(
        this.mesh.position,
        new THREE.Vector3(0.6, this.height, 0.6)
      );
    }

    boxIntersect(pos, obstacle) {
      // Simple AABB collision check player (at pos) vs obstacle
      const playerMin = new THREE.Vector3(pos.x - 0.3, pos.y - this.height/2, pos.z - 0.3);
      const playerMax = new THREE.Vector3(pos.x + 0.3, pos.y + this.height/2, pos.z + 0.3);

      const obsBB = new THREE.Box3().setFromObject(obstacle);

      return playerMin.x <= obsBB.max.x &&
             playerMax.x >= obsBB.min.x &&
             playerMin.y <= obsBB.max.y &&
             playerMax.y >= obsBB.min.y &&
             playerMin.z <= obsBB.max.z &&
             playerMax.z >= obsBB.min.z;
    }
  }

  // ======= Multiplayer Setup =======
  // Connect to your socket.io server here
  // Replace with your server URL
  const socket = io('https://your-socket-server-url');

  const players = new Map();
  let localPlayer = null;

  // Join and assign ID
  socket.on('connect', () => {
    console.log('Connected to server with id', socket.id);
    localPlayer = new Player(socket.id, true);
    players.set(socket.id, localPlayer);
    socket.emit('newPlayer', {id: socket.id});
  });

  // New player joined
  socket.on('playerJoined', (data) => {
    if(data.id !== socket.id && !players.has(data.id)) {
      const p = new Player(data.id, false);
      players.set(data.id, p);
      console.log('Player joined:', data.id);
    }
  });

  // Player moved
  socket.on('playerMoved', (data) => {
    if(data.id !== socket.id) {
      const p = players.get(data.id);
      if(p) {
        p.position.set(data.x, data.y, data.z);
      }
    }
  });

  // Player disconnected
  socket.on('playerLeft', (id) => {
    const p = players.get(id);
    if(p) {
      scene.remove(p.mesh);
      players.delete(id);
      console.log('Player left:', id);
    }
  });

  // Send local player position periodically
  setInterval(() => {
    if(localPlayer) {
      socket.emit('playerMove', {
        id: localPlayer.id,
        x: localPlayer.position.x,
        y: localPlayer.position.y,
        z: localPlayer.position.z
      });
    }
  }, 50);

  // ======= Mod Menu & Features =======
  const espToggle = document.getElementById('espToggle');
  const tracerToggle = document.getElementById('tracerToggle');
  const aimbotToggle = document.getElementById('aimbotToggle');

  let isRMBDown = false;
  window.addEventListener('mousedown', e => {
    if(e.button === 2) isRMBDown = true;
  });
  window.addEventListener('mouseup', e => {
    if(e.button === 2) isRMBDown = false;
  });
  // Prevent context menu on right click
  window.addEventListener('contextmenu', e => e.preventDefault());

  // ======= Helper functions for ESP and Tracers =======
  function worldToScreen(pos) {
    const vector = pos.clone();
    vector.project(camera);
    const x = (vector.x + 1) / 2 * window.innerWidth;
    const y = (-vector.y + 1) / 2 * window.innerHeight;
    return {x, y, z: vector.z};
  }

  // ======= Aimbot lock-on =======
  function aimbot() {
    if(!localPlayer) return;
    let closest = null;
    let closestDist = Infinity;

    for(let [id, player] of players) {
      if(id === localPlayer.id) continue;

      const dist = localPlayer.position.distanceTo(player.position);
      if(dist < closestDist) {
        closestDist = dist;
        closest = player;
      }
    }
    if(!closest) return;

    // Calculate angles to target for camera rotation
    const targetPos = closest.position.clone();
    targetPos.y += 1.5; // aim at head height

    const direction = targetPos.clone().sub(localPlayer.position).normalize();

    // Convert direction to yaw (y rotation) and pitch (x rotation)
    const yaw = Math.atan2(direction.x, direction.z);
    const pitch = Math.asin(direction.y);

    // Smooth rotation (lerp)
    const controlsObj = localPlayer.controls.getObject();

    const currentYaw = controlsObj.rotation.y;
    const currentPitch = controlsObj.rotation.x;

    // Lerp rotation angles (0.1 speed)
    controlsObj.rotation.y += (yaw - currentYaw) * 0.1;
    controlsObj.rotation.x += (pitch - currentPitch) * 0.1;
  }

  // ======= Main Loop =======
  const clock = new THREE.Clock();

  function animate() {
    requestAnimationFrame(animate);
    const delta = clock.getDelta();

    if(localPlayer) {
      localPlayer.update(delta);

      if(aimbotToggle.checked && isRMBDown) {
        aimbot();
      }
    }

    renderer.render(scene, camera);

    // Draw ESP & Tracers overlay
    ctx.clearRect(0, 0, overlay.width, overlay.height);

    if(localPlayer) {
      for(let [id, player] of players) {
        if(id === localPlayer.id) continue;

        if(espToggle.checked) {
          // Draw 2D box around player projected on screen
          const min = player.boundingBox.min.clone();
          const max = player.boundingBox.max.clone();

          // 8 corners of the box
          const points = [
            new THREE.Vector3(min.x, min.y, min.z),
            new THREE.Vector3(max.x, min.y, min.z),
            new THREE.Vector3(max.x, max.y, min.z),
            new THREE.Vector3(min.x, max.y, min.z),
            new THREE.Vector3(min.x, min.y, max.z),
            new THREE.Vector3(max.x, min.y, max.z),
            new THREE.Vector3(max.x, max.y, max.z),
            new THREE.Vector3(min.x, max.y, max.z),
          ];

          const screenPoints = points.map(p => worldToScreen(p));

          const xs = screenPoints.map(p => p.x);
          const ys = screenPoints.map(p => p.y);

          const minX = Math.min(...xs);
          const maxX = Math.max(...xs);
          const minY = Math.min(...ys);
          const maxY = Math.max(...ys);

          ctx.strokeStyle = 'lime';
          ctx.lineWidth = 2;
          ctx.strokeRect(minX, minY, maxX - minX, maxY - minY);
        }

        if(tracerToggle.checked) {
          // Draw line from bottom center to player center on screen
          const screenPos = worldToScreen(player.mesh.position.clone().setY(player.position.y + 0.9));
          ctx.strokeStyle = 'red';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(window.innerWidth/2, window.innerHeight);
          ctx.lineTo(screenPos.x, screenPos.y);
          ctx.stroke();
        }
      }
    }
  }
  animate();

})();
</script>

</body>
</html>

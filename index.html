<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D FPS Shooter with Mod Menu</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #hud {
      position: absolute;
      top: 10px; left: 10px;
      color: white;
      font-family: sans-serif;
      font-size: 18px;
      z-index: 10;
    }
    #modMenu {
      display: none;
      position: absolute;
      top: 50px; right: 20px;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 15px;
      border: 2px solid #0ff;
      font-family: sans-serif;
      z-index: 20;
    }
    #modMenu h2 {
      margin-top: 0;
    }
    #modMenu label {
      display: block;
      margin: 5px 0;
    }
  </style>
</head>
<body>
<div id="hud">Health: <span id="health">100</span></div>
<div id="modMenu">
  <h2>Mod Menu</h2>
  <label><input type="checkbox" id="espToggle" /> ESP</label>
  <label><input type="checkbox" id="tracerToggle" /> Tracers</label>
  <label><input type="checkbox" id="aimbotToggle" /> Aimbot (hold RMB)</label>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.125.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.125.2/examples/js/controls/PointerLockControls.js"></script>

<script>
let scene = new THREE.Scene();
let camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
let renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

let controls = new THREE.PointerLockControls(camera, document.body);
scene.add(controls.getObject());

// Lights
scene.add(new THREE.HemisphereLight(0xffffff, 0x333333, 1));

// Floor
let floor = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), new THREE.MeshStandardMaterial({ color: 0x444444 }));
floor.rotation.x = -Math.PI / 2;
floor.receiveShadow = true;
scene.add(floor);

// Health
let health = 100;
const healthDisplay = document.getElementById("health");

// Keys
const keys = {};
document.addEventListener('keydown', e => keys[e.code] = true);
document.addEventListener('keyup', e => keys[e.code] = false);

// Player Physics
camera.position.set(0, 1.6, 0);
const velocity = new THREE.Vector3();
const direction = new THREE.Vector3();
let onGround = false;

// Obstacles
const obstacles = [];
function createObstacle(x, z) {
  const o = new THREE.Mesh(new THREE.BoxGeometry(5, 4, 2), new THREE.MeshStandardMaterial({ color: 0x888888 }));
  o.position.set(x, 2, z);
  scene.add(o);
  obstacles.push(o);
}
for (let i = 0; i < 12; i++) createObstacle((Math.random() - 0.5) * 100, (Math.random() - 0.5) * 100);

// Enemies
let enemies = [];
function spawnEnemy() {
  const e = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), new THREE.MeshStandardMaterial({ color: 0xff0000 }));
  e.position.set((Math.random() - 0.5) * 80, 1, (Math.random() - 0.5) * 80);
  e.userData.health = 100;
  scene.add(e);
  enemies.push(e);
}
for (let i = 0; i < 5; i++) spawnEnemy();

// Bullets
const bullets = [];
document.addEventListener("click", () => {
  if (!controls.isLocked) return;
  const bullet = new THREE.Mesh(new THREE.SphereGeometry(0.1), new THREE.MeshBasicMaterial({ color: 0xffff00 }));
  bullet.position.copy(camera.position);
  const dir = new THREE.Vector3();
  camera.getWorldDirection(dir);
  bullet.userData.velocity = dir.clone().multiplyScalar(1);
  bullets.push(bullet);
  scene.add(bullet);
});

// Collision
function collides(pos) {
  for (let obj of obstacles) {
    const dx = Math.abs(pos.x - obj.position.x);
    const dz = Math.abs(pos.z - obj.position.z);
    if (dx < 3 && dz < 3) return true;
  }
  return false;
}

// MODS
let espEnabled = false;
let tracerEnabled = false;
let aimbotEnabled = false;
const modMenu = document.getElementById('modMenu');

document.getElementById('espToggle').addEventListener('change', e => espEnabled = e.target.checked);
document.getElementById('tracerToggle').addEventListener('change', e => tracerEnabled = e.target.checked);
document.getElementById('aimbotToggle').addEventListener('change', e => aimbotEnabled = e.target.checked);

// Toggle Mod Menu with ";"
document.addEventListener('keydown', e => {
  if (e.key === ';') {
    modMenu.style.display = modMenu.style.display === 'block' ? 'none' : 'block';
    if (modMenu.style.display === 'block') {
      document.exitPointerLock();
    } else {
      controls.lock();
    }
  }
});

// Aimbot
let mouseDownRMB = false;
document.addEventListener('mousedown', e => { if (e.button === 2) mouseDownRMB = true; });
document.addEventListener('mouseup', e => { if (e.button === 2) mouseDownRMB = false; });

let tracerLines = [];
let espBoxes = [];

function clearDebug() {
  tracerLines.forEach(l => scene.remove(l));
  espBoxes.forEach(b => scene.remove(b));
  tracerLines = [];
  espBoxes = [];
}

// Animate
function animate() {
  requestAnimationFrame(animate);

  direction.set(0, 0, 0);
  if (keys['KeyW']) direction.z -= 1;
  if (keys['KeyS']) direction.z += 1;
  if (keys['KeyA']) direction.x -= 1;
  if (keys['KeyD']) direction.x += 1;
  direction.normalize().applyQuaternion(camera.quaternion);
  direction.y = 0;

  const nextPos = controls.getObject().position.clone().add(direction.clone().multiplyScalar(0.2));
  if (!collides(nextPos)) controls.getObject().position.copy(nextPos);

  if (!onGround) {
    controls.getObject().position.y -= 0.2;
    if (controls.getObject().position.y <= 1.6) {
      controls.getObject().position.y = 1.6;
      onGround = true;
    }
  }

  // Enemies
  for (let i = enemies.length - 1; i >= 0; i--) {
    let e = enemies[i];
    if (!e.userData) continue;

    let dist = e.position.distanceTo(controls.getObject().position);
    if (dist > 1.2) {
      const dir = new THREE.Vector3().subVectors(controls.getObject().position, e.position).normalize();
      e.position.addScaledVector(dir, 0.03);
    } else {
      health = Math.max(0, health - 0.2);
      healthDisplay.textContent = Math.floor(health);
    }
  }

  // Bullets
  for (let i = bullets.length - 1; i >= 0; i--) {
    let b = bullets[i];
    b.position.add(b.userData.velocity);
    for (let j = enemies.length - 1; j >= 0; j--) {
      let e = enemies[j];
      if (b.position.distanceTo(e.position) < 1) {
        e.userData.health -= 50;
        if (e.userData.health <= 0) {
          scene.remove(e);
          enemies.splice(j, 1);
          setTimeout(() => spawnEnemy(), 3000);
        }
        scene.remove(b);
        bullets.splice(i, 1);
        break;
      }
    }
    if (b.position.length() > 200) {
      scene.remove(b);
      bullets.splice(i, 1);
    }
  }

  // Mod Features
  clearDebug();
  enemies.forEach(e => {
    if (espEnabled) {
      const box = new THREE.BoxHelper(e, 0xff0000);
      scene.add(box);
      espBoxes.push(box);
    }
    if (tracerEnabled) {
      const mat = new THREE.LineBasicMaterial({ color: 0x00ffff });
      const geom = new THREE.BufferGeometry().setFromPoints([camera.position.clone(), e.position.clone()]);
      const line = new THREE.Line(geom, mat);
      scene.add(line);
      tracerLines.push(line);
    }
  });

  // Aimbot
  if (aimbotEnabled && mouseDownRMB && enemies.length > 0) {
    let closest = enemies.reduce((a, b) =>
      a.position.distanceTo(camera.position) < b.position.distanceTo(camera.position) ? a : b
    );
    let dir = new THREE.Vector3().subVectors(closest.position, camera.position).normalize();
    camera.lookAt(camera.position.clone().add(dir));
  }

  renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Multiplayer FPS Game</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #hud, #crosshair, #status, #playerList {
      position: absolute;
      font-family: sans-serif;
      z-index: 10;
    }
    #hud {
      top: 10px; left: 10px;
      font-size: 16px;
      color: white;
    }
    #crosshair {
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      font-size: 14px;
      color: white;
      pointer-events: none;
    }
    #status {
      top: 10px; right: 10px;
      font-size: 14px;
      color: yellow;
      background: rgba(0, 0, 0, 0.5);
      padding: 6px;
      border-radius: 6px;
    }
    #playerList {
      top: 50px; right: 10px;
      color: lightgreen;
      font-size: 13px;
      background: rgba(0, 0, 0, 0.5);
      padding: 5px;
      border-radius: 6px;
      max-width: 150px;
    }
  </style>
</head>
<body>
  <div id="hud">Health: <span id="health">100</span></div>
  <div id="crosshair">+</div>
  <div id="status">Connecting...</div>
  <div id="playerList">Players:<br/></div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.125.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.125.2/examples/js/controls/PointerLockControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/peerjs@1.4.7/dist/peerjs.min.js"></script>

  <script>
    // === Basic Setup ===
    let scene = new THREE.Scene();
    let camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    let renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    let controls = new THREE.PointerLockControls(camera, document.body);
    document.body.addEventListener('click', () => controls.lock());
    scene.add(controls.getObject());

    let health = 100;
    let isDead = false;
    const healthDisplay = document.getElementById("health");
    const statusDisplay = document.getElementById("status");
    const playerListDisplay = document.getElementById("playerList");

    const keys = {};
    document.addEventListener('keydown', e => keys[e.code] = true);
    document.addEventListener('keyup', e => keys[e.code] = false);

    scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1));

    // Floor
    let floor = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), new THREE.MeshStandardMaterial({ color: 0x222 }));
    floor.rotation.x = -Math.PI / 2;
    scene.add(floor);

    // Obstacles
    const obstacles = [];
    for (let i = 0; i < 15; i++) {
      let box = new THREE.Mesh(new THREE.BoxGeometry(5, 6, 2), new THREE.MeshStandardMaterial({ color: 0x777 }));
      box.position.set((Math.random()-0.5)*100, 3, (Math.random()-0.5)*100);
      scene.add(box);
      obstacles.push(box);
    }

    function collides(pos) {
      for (let o of obstacles) {
        let dx = Math.abs(pos.x - o.position.x);
        let dz = Math.abs(pos.z - o.position.z);
        if (dx < 3 && dz < 3) return true;
      }
      return false;
    }

    camera.position.set(0, 1.6, 0);

    // === Multiplayer ===
    const ROOM_ID = "shared-room";
    let peer, isHost = false;
    let connections = {};
    const remotePlayers = {};

    function createRemoteMesh(color=0x00f) {
      return new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), new THREE.MeshStandardMaterial({ color }));
    }

    function updatePlayerList() {
      let list = "Players:<br/>";
      list += "You<br/>";
      for (let id in remotePlayers) list += id + "<br/>";
      playerListDisplay.innerHTML = list;
    }

    function setupConnection(conn) {
      connections[conn.peer] = conn;
      conn.on('data', data => {
        if (data.type === 'position') {
          if (!remotePlayers[conn.peer]) {
            let mesh = createRemoteMesh();
            scene.add(mesh);
            remotePlayers[conn.peer] = { mesh, lastUpdate: Date.now(), health: 100 };
            updatePlayerList();
          }
          let rp = remotePlayers[conn.peer];
          rp.mesh.position.set(data.x, data.y, data.z);
          rp.lastUpdate = Date.now();
        }
        if (data.type === 'hit') {
          if (!isDead) {
            health -= 25;
            if (health <= 0) dieAndRespawn();
          }
        }
      });
      conn.on('close', () => {
        if (remotePlayers[conn.peer]) {
          scene.remove(remotePlayers[conn.peer].mesh);
          delete remotePlayers[conn.peer];
          updatePlayerList();
        }
        delete connections[conn.peer];
      });
    }

    function startPeer() {
      peer = new Peer(ROOM_ID, { debug: 1 });
      peer.on('open', id => {
        statusDisplay.textContent = "Connected as Host";
        isHost = true;
      });
      peer.on('connection', conn => setupConnection(conn));
      peer.on('error', err => {
        if (err.type === 'unavailable-id') startClient();
      });
    }

    function startClient() {
      peer = new Peer();
      peer.on('open', id => {
        statusDisplay.textContent = "Connected as Client";
        let conn = peer.connect(ROOM_ID);
        conn.on('open', () => setupConnection(conn));
      });
    }

    startPeer();

    // === Shooting ===
    const bullets = [];
    document.addEventListener('click', () => {
      if (isDead) return;
      let bullet = new THREE.Mesh(new THREE.SphereGeometry(0.1), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
      bullet.position.copy(camera.position);
      bullet.direction = camera.getWorldDirection(new THREE.Vector3()).clone();
      scene.add(bullet);
      bullets.push(bullet);
    });

    function checkBulletHit(bullet) {
      for (let id in remotePlayers) {
        let player = remotePlayers[id];
        let dist = bullet.position.distanceTo(player.mesh.position);
        if (dist < 1.5) {
          connections[id]?.send({ type: 'hit' });
          return true;
        }
      }
      return false;
    }

    // === Death + Respawn ===
    function dieAndRespawn() {
      isDead = true;
      health = 0;
      healthDisplay.textContent = "DEAD";
      controls.getObject().position.set(999, -999, 999); // hide
      setTimeout(() => {
        isDead = false;
        health = 100;
        healthDisplay.textContent = health;
        controls.getObject().position.set(Math.random()*20-10, 1.6, Math.random()*20-10);
      }, 3000);
    }

    // === Game Loop ===
    const direction = new THREE.Vector3();

    function animate() {
      requestAnimationFrame(animate);

      if (!isDead) {
        direction.set(0, 0, 0);
        if (keys["KeyW"]) direction.z -= 1;
        if (keys["KeyS"]) direction.z += 1;
        if (keys["KeyA"]) direction.x -= 1;
        if (keys["KeyD"]) direction.x += 1;
        direction.normalize().applyQuaternion(camera.quaternion);
        direction.y = 0;

        let speed = 0.2;
        let next = controls.getObject().position.clone().add(direction.multiplyScalar(speed));
        if (!collides(next)) controls.getObject().position.copy(next);

        // Send position
        for (let id in connections) {
          if (connections[id].open) {
            connections[id].send({
              type: "position",
              x: camera.position.x,
              y: camera.position.y,
              z: camera.position.z
            });
          }
        }
      }

      // Move bullets
      for (let i = bullets.length - 1; i >= 0; i--) {
        let b = bullets[i];
        b.position.add(b.direction.clone().multiplyScalar(0.5));
        if (checkBulletHit(b)) {
          scene.remove(b);
          bullets.splice(i, 1);
        }
        if (b.position.length() > 500) {
          scene.remove(b);
          bullets.splice(i, 1);
        }
      }

      healthDisplay.textContent = isDead ? "DEAD" : Math.floor(health);
      renderer.render(scene, camera);
    }

    animate();

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>

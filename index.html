<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Multiplayer FPS Game â€“ Mods</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #hud, #crosshair, #status, #playerList, #chat, #chatInput {
      position: absolute;
      font-family: sans-serif;
      z-index: 10;
    }
    #hud { top: 10px; left: 10px; font-size: 16px; color: white; }
    #crosshair {
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      font-size: 14px; color: white;
      pointer-events: none;
    }
    #status {
      top: 10px; right: 10px;
      font-size: 14px;
      color: yellow;
      background: rgba(0, 0, 0, 0.5);
      padding: 6px;
      border-radius: 6px;
    }
    #playerList {
      top: 50px; right: 10px;
      color: lightgreen;
      font-size: 13px;
      background: rgba(0, 0, 0, 0.5);
      padding: 5px;
      border-radius: 6px;
      max-width: 150px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    #chat {
      bottom: 10px; left: 10px;
      width: 300px;
      max-height: 150px;
      overflow-y: auto;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 8px;
      border-radius: 6px;
      font-size: 14px;
      user-select: none;
    }
    #chatInput {
      bottom: 170px; left: 10px;
      width: 300px;
      display: none;
      font-size: 14px;
      padding: 6px;
      border-radius: 6px;
      border: none;
      outline: none;
      background: rgba(255,255,255,0.9);
      color: black;
    }
  </style>
</head>
<body>
  <div id="hud">Health: <span id="health">100</span></div>
  <div id="crosshair">+</div>
  <div id="status">Connecting...</div>
  <div id="playerList">Players:<br/></div>
  <div id="chat"></div>
  <input id="chatInput" type="text" placeholder="Type your message and press Enter..." />

  <script src="https://cdn.jsdelivr.net/npm/three@0.125.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.125.2/examples/js/controls/PointerLockControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/peerjs@1.4.7/dist/peerjs.min.js"></script>

  <script>
    // === Initialization ===
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new THREE.PointerLockControls(camera, document.body);
    document.body.addEventListener('click', () => controls.lock());
    scene.add(controls.getObject());

    let health = 100, isDead = false;
    const healthDisplay = document.getElementById("health");
    const statusDisplay = document.getElementById("status");
    const playerListDisplay = document.getElementById("playerList");
    const chatDisplay = document.getElementById("chat");
    const chatInput = document.getElementById("chatInput");
    const keys = {};
    document.addEventListener('keydown', e => {
      if(chatInput.style.display === "block"){
        // When chat input is open, only allow typing inside it
        if(e.key === 'Enter'){
          const msg = chatInput.value.trim();
          if(msg) sendChatMessage(msg);
          chatInput.value = '';
          chatInput.style.display = "none";
          controls.lock();
        }
        if(e.key === 'Escape'){
          chatInput.value = '';
          chatInput.style.display = "none";
          controls.lock();
        }
        e.stopPropagation();
        return;
      }
      keys[e.code] = true;
      if (e.key === '/') {
        e.preventDefault();
        chatInput.style.display = "block";
        chatInput.focus();
      } else if (e.key === 'Escape') {
        chatInput.value = "";
        chatInput.style.display = "none";
        controls.lock();
      }
    });
    document.addEventListener('keyup', e => keys[e.code] = false);
    chatInput.addEventListener('keydown', e => {
      if (e.key === 'Enter') {
        const msg = chatInput.value.trim();
        if (msg) sendChatMessage(msg);
        chatInput.value = '';
        chatInput.style.display = "none";
        controls.lock();
      }
      e.stopPropagation();
    });

    // Lighting
    scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1));
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(5, 10, 7);
    scene.add(dirLight);

    // Floor
    const floor = new THREE.Mesh(
      new THREE.PlaneGeometry(200, 200),
      new THREE.MeshStandardMaterial({ color: 0x888877 })
    );
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    // Obstacles
    const containerColors = [0x0055ff, 0xff3333, 0x33cc33, 0xffff33];
    const obstacles = [];
    for (let i = 0; i < 15; i++) {
      const color = containerColors[i % containerColors.length];
      const box = new THREE.Mesh(
        new THREE.BoxGeometry(5, 6, 2),
        new THREE.MeshStandardMaterial({ color })
      );
      box.position.set((Math.random() - 0.5) * 100, 3, (Math.random() - 0.5) * 100);
      box.castShadow = true;
      box.receiveShadow = true;
      scene.add(box);
      obstacles.push(box);
    }

    function collides(pos) {
      for (let o of obstacles) {
        if (
          Math.abs(pos.x - o.position.x) < 3 &&
          Math.abs(pos.z - o.position.z) < 3
        ) return true;
      }
      return false;
    }

    camera.position.set(0, 2, 10);
    controls.getObject().position.set(0, 1.6, 10);

    // PeerJS Multiplayer Setup
    const ROOM_ID = "shared-room";
    let peer, isHost = false;
    const connections = {}, remotePlayers = {};

    function updatePlayerList() {
      let html = "Players:<br/>You<br/>";
      for (const id in remotePlayers) html += id + "<br/>";
      playerListDisplay.innerHTML = html;
    }

    function createRemoteMesh() {
      const group = new THREE.Group();
      const body = new THREE.Mesh(
        new THREE.BoxGeometry(1, 2, 1),
        new THREE.MeshStandardMaterial({ color: 0x0000ff })
      );
      body.position.y = 1;
      const cone = new THREE.Mesh(
        new THREE.ConeGeometry(0.3, 0.7, 8),
        new THREE.MeshStandardMaterial({ color: 0xffaa00 })
      );
      cone.position.set(0, 2, 0.75);
      cone.rotation.x = Math.PI;
      group.add(body);
      group.add(cone);
      return group;
    }

    function addChatMessage(sender, message) {
      const div = document.createElement('div');
      div.textContent = sender + ": " + message;
      chatDisplay.appendChild(div);
      chatDisplay.scrollTop = chatDisplay.scrollHeight;
    }

    function setupConnection(conn) {
      connections[conn.peer] = conn;
      conn.on('data', data => {
        if (data.type === 'position') {
          if (!remotePlayers[conn.peer]) {
            const mesh = createRemoteMesh();
            scene.add(mesh);
            remotePlayers[conn.peer] = { mesh, health: 100 };
            updatePlayerList();
          }
          remotePlayers[conn.peer].mesh.position.set(data.x, 1, data.z);
          if (data.rotationY !== undefined) {
            remotePlayers[conn.peer].mesh.rotation.y = data.rotationY;
          }
        } else if (data.type === 'hit') {
          if (!isDead) {
            health -= 25;
            if (health <= 0) dieAndRespawn();
          }
        } else if (data.type === 'chat') {
          addChatMessage(conn.peer, data.message);
        }
      });
      conn.on('close', () => {
        if (remotePlayers[conn.peer]) {
          scene.remove(remotePlayers[conn.peer].mesh);
          delete remotePlayers[conn.peer];
          updatePlayerList();
        }
        delete connections[conn.peer];
      });
    }

    function startPeerAsHost() {
      peer = new Peer(ROOM_ID, { debug: 1 });
      peer.on('open', () => {
        statusDisplay.textContent = "Connected as Host";
        isHost = true;
      });
      peer.on('connection', conn => setupConnection(conn));
      peer.on('error', err => {
        if (err.type === 'unavailable-id') startPeerAsClient();
      });
    }

    function startPeerAsClient() {
      peer = new Peer({ debug: 1 });
      peer.on('open', () => {
        statusDisplay.textContent = "Connected as Client";
        const conn = peer.connect(ROOM_ID);
        conn.on('open', () => setupConnection(conn));
      });
    }

    startPeerAsHost();

    function sendChatMessage(message) {
      addChatMessage("You", message);
      for (const id in connections) {
        if (connections[id].open) connections[id].send({ type: 'chat', message });
      }
    }

    // === Bullet Logic ===
    const bullets = [];
    document.addEventListener('click', () => {
      if (isDead || chatInput.style.display === "block") return;
      const dir = camera.getWorldDirection(new THREE.Vector3()).clone();
      const start = camera.position.clone();
      const bullet = {
        mesh: new THREE.Mesh(
          new THREE.SphereGeometry(0.1),
          new THREE.MeshBasicMaterial({ color: 0xff0000 })
        ),
        position: start.clone(),
        direction: dir.clone(),
        speed: 0.5
      };
      bullet.mesh.position.copy(bullet.position);
      scene.add(bullet.mesh);
      bullets.push(bullet);
    });

    function checkBulletHit(bullet) {
      for (const id in remotePlayers) {
        const player = remotePlayers[id];
        if (bullet.position.distanceTo(player.mesh.position) < 1.5) {
          connections[id]?.send({ type: 'hit' });
          return true;
        }
      }
      return false;
    }

    // === Mod Menu & States ===
    let mods = {
      tracers: false,
      aimbot: false,
      esp: false,
      triggerbot: false,
      homing: false
    };

    const modMenu = document.createElement("div");
    modMenu.style.position = "absolute";
    modMenu.style.top = "50px";
    modMenu.style.left = "50px";
    modMenu.style.background = "rgba(0,0,0,0.8)";
    modMenu.style.color = "white";
    modMenu.style.padding = "10px";
    modMenu.style.border = "2px solid white";
    modMenu.style.borderRadius = "8px";
    modMenu.style.display = "none";
    modMenu.style.zIndex = "99";
    modMenu.innerHTML = `
      <strong>Mod Menu</strong><br>
      <label><input type="checkbox" id="espToggle"> ESP (Green Box)</label><br>
      <label><input type="checkbox" id="tracersToggle"> Tracers (Red Lines)</label><br>
      <label><input type="checkbox" id="aimbotToggle"> Aimbot (Right Click)</label><br>
      <label><input type="checkbox" id="triggerbotToggle"> Triggerbot</label><br>
      <label><input type="checkbox" id="homingToggle"> Homing Bullets</label>
    `;
    document.body.appendChild(modMenu);

    document.getElementById("espToggle").onchange       = e => mods.esp       = e.target.checked;
    document.getElementById("tracersToggle").onchange  = e => mods.tracers  = e.target.checked;
    document.getElementById("aimbotToggle").onchange   = e => mods.aimbot   = e.target.checked;
    document.getElementById("triggerbotToggle").onchange = e => mods.triggerbot = e.target.checked;
    document.getElementById("homingToggle").onchange   = e => mods.homing   = e.target.checked;

    document.addEventListener("keydown", e => {
      if (e.key === ";") modMenu.style.display =
        modMenu.style.display === "none" ? "block" : "none";
    });

    // === ESP & Tracer Helpers ===
    const tracerLines = [], espBoxes = [];
    function clearHelpers() {
      tracerLines.forEach(line => scene.remove(line));
      tracerLines.length = 0;
      espBoxes.forEach(box => scene.remove(box));
      espBoxes.length = 0;
    }
    function updateESPAndTracers() {
      clearHelpers();
      const start = controls.getObject().position.clone().add(new THREE.Vector3(0,1.6,0));
      for (const id in remotePlayers) {
        const enemy = remotePlayers[id];
        if (mods.esp) {
          const box = new THREE.BoxHelper(enemy.mesh);
          box.material.color.set(0x00ff00);
          box.material.depthTest = false;
          box.renderOrder = 999;
          espBoxes.push(box);
          scene.add(box);
        }
        if (mods.tracers) {
          const end = enemy.mesh.position.clone().add(new THREE.Vector3(0,1,0));
          const geom = new THREE.BufferGeometry().setFromPoints([start, end]);
          const mat = new THREE.LineBasicMaterial({ color:0xff0000, depthTest:false });
          const line = new THREE.Line(geom, mat);
          line.renderOrder = 998;
          tracerLines.push(line);
          scene.add(line);
        }
      }
    }

    // === Aiming & Triggerbot Helpers ===
    let isAiming = false;
    document.addEventListener("mousedown", e => { if (e.button===2) isAiming=true; });
    document.addEventListener("mouseup",   e => { if (e.button===2) isAiming=false; });
    function getClosestEnemy() {
      let closest=null, dist=Infinity;
      for (const id in remotePlayers) {
        const d = camera.position.distanceTo(remotePlayers[id].mesh.position);
        if (d<dist) { dist=d; closest=remotePlayers[id]; }
      }
      return closest;
    }
    function enemyInCrosshair(enemy){
      if(!enemy) return false;
      const v = enemy.mesh.position.clone().add(new THREE.Vector3(0,1,0)).project(camera);
      return Math.abs(v.x)<0.05 && Math.abs(v.y)<0.05;
    }

    // === Death and Respawn ===
    function dieAndRespawn(){
      isDead = true;
      health = 0;
      healthDisplay.textContent = 'DEAD';
      statusDisplay.textContent = "You died. Respawning in 3 seconds...";
      setTimeout(() => {
        health = 100;
        isDead = false;
        statusDisplay.textContent = "Alive";
        controls.getObject().position.set(0, 1.6, 10);
      }, 3000);
    }

    // === Movement & Position Sending ===
    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();
    const speed = 0.1;

    function updatePositionAndSend(){
      if(isDead) return;
      velocity.x = 0;
      velocity.z = 0;
      if(keys['KeyW']) velocity.z -= speed;
      if(keys['KeyS']) velocity.z += speed;
      if(keys['KeyA']) velocity.x -= speed;
      if(keys['KeyD']) velocity.x += speed;

      // Rotate velocity vector by camera Y rotation
      const angle = controls.getObject().rotation.y;
      const sin = Math.sin(angle);
      const cos = Math.cos(angle);

      const dx = velocity.x * cos - velocity.z * sin;
      const dz = velocity.x * sin + velocity.z * cos;

      const newPos = controls.getObject().position.clone();
      newPos.x += dx;
      newPos.z += dz;

      // Collision check
      if(!collides(newPos)){
        controls.getObject().position.copy(newPos);
      }

      // Send position + rotationY to all connected peers
      for(const id in connections){
        if(connections[id].open){
          connections[id].send({
            type: 'position',
            x: controls.getObject().position.x,
            z: controls.getObject().position.z,
            rotationY: controls.getObject().rotation.y
          });
        }
      }
    }

    // === Main Animate Loop ===
    let triggerbotCooldown=0;
    function animate(){
      requestAnimationFrame(animate);

      updatePositionAndSend();

      // Update bullets with homing logic
      for(let i=bullets.length-1; i>=0; i--){
        const b = bullets[i];

        if(mods.homing){
          let closest=null, md=Infinity;
          for(const id in remotePlayers){
            const p = remotePlayers[id].mesh.position;
            const d = b.position.distanceTo(p);
            if(d<md){ md=d; closest=p; }
          }
          if(closest){
            const desired = closest.clone().sub(b.position).normalize();
            b.direction.lerp(desired, 0.1).normalize();
          }
        }

        b.position.add(b.direction.clone().multiplyScalar(b.speed));
        b.mesh.position.copy(b.position);

        if(checkBulletHit(b)){
          scene.remove(b.mesh);
          bullets.splice(i,1);
          continue;
        }

        // Remove bullet if too far away
        if(b.position.distanceTo(camera.position)>100){
          scene.remove(b.mesh);
          bullets.splice(i,1);
        }
      }

      // Aimbot logic
      if(mods.aimbot && isAiming && !isDead){
        const target = getClosestEnemy();
        if(target){
          const dir = target.mesh.position.clone().sub(controls.getObject().position);
          const yrot = Math.atan2(dir.x, dir.z);
          controls.getObject().rotation.y = yrot;
        }
      }

      // Triggerbot logic (automatic shooting when enemy in crosshair)
      if(mods.triggerbot && !isDead){
        if(triggerbotCooldown<=0){
          const target = getClosestEnemy();
          if(enemyInCrosshair(target)){
            // Shoot a bullet automatically
            const dir = camera.getWorldDirection(new THREE.Vector3()).clone();
            const start = camera.position.clone();
            const bullet = {
              mesh: new THREE.Mesh(
                new THREE.SphereGeometry(0.1),
                new THREE.MeshBasicMaterial({ color: 0xff0000 })
              ),
              position: start.clone(),
              direction: dir.clone(),
              speed: 0.5
            };
            bullet.mesh.position.copy(bullet.position);
            scene.add(bullet.mesh);
            bullets.push(bullet);
            triggerbotCooldown = 30; // frames cooldown
          }
        } else {
          triggerbotCooldown--;
        }
      }

      updateESPAndTracers();

      renderer.render(scene, camera);
      healthDisplay.textContent = health;
    }
    animate();

    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>

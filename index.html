<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Multiplayer FPS Game â€“ Mods</title>
  <style>
    body { margin: 0; overflow: hidden; background: #111; }
    canvas { display: block; }

    #modMenu {
      position: fixed;
      top: 10px;
      right: 10px;
      width: 300px;
      max-height: 90vh;
      background: rgba(0,0,0,0.8);
      color: #0f0;
      font-family: monospace;
      font-size: 14px;
      overflow-y: auto;
      border: 2px solid #0f0;
      padding: 10px;
      z-index: 9999;
      user-select: none;
    }

    #modMenu h2 {
      margin-top: 0;
      color: #0ff;
    }

    .mod {
      margin: 5px 0;
      cursor: pointer;
      padding: 5px;
      border: 1px solid #0f0;
      border-radius: 4px;
      background: rgba(0, 255, 0, 0.1);
    }
    .mod.active {
      background: rgba(0, 255, 0, 0.4);
      font-weight: bold;
    }

    #crosshair {
      position: fixed;
      top: 50%;
      left: 50%;
      width: 20px;
      height: 20px;
      margin-left: -10px;
      margin-top: -10px;
      pointer-events: none;
      z-index: 10000;
    }
    #crosshair:before, #crosshair:after {
      content: '';
      position: absolute;
      background: red;
    }
    #crosshair:before {
      left: 9px;
      top: 0;
      width: 2px;
      height: 20px;
    }
    #crosshair:after {
      top: 9px;
      left: 0;
      width: 20px;
      height: 2px;
    }

  </style>
</head>
<body>

  <div id="modMenu">
    <h2>Mod Menu</h2>
    <div id="aimbotToggle" class="mod">Aimbot: OFF</div>
    <div id="triggerbotToggle" class="mod">Triggerbot: OFF</div>
    <div id="homingToggle" class="mod">Homing Bullets: OFF</div>
    <div id="espToggle" class="mod">2D ESP: OFF</div>
    <div id="tracerToggle" class="mod">Tracer Lines: OFF</div>
  </div>

  <div id="crosshair"></div>

  <canvas id="gameCanvas"></canvas>

  <!-- Always keep these exact scripts in this order and version -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.125.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.125.2/examples/js/controls/PointerLockControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/peerjs@1.4.7/dist/peerjs.min.js"></script>

  <script>
    // Basic setup
    const canvas = document.getElementById('gameCanvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Scene and camera
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 2, 5);

    // Controls (PointerLock for FPS)
    const controls = new THREE.PointerLockControls(camera, document.body);
    document.body.addEventListener('click', () => {
      controls.lock();
    });

    // Lighting
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(5,10,7.5);
    scene.add(light);

    // Floor
    const floorGeometry = new THREE.PlaneGeometry(50,50);
    const floorMaterial = new THREE.MeshStandardMaterial({color:0x222222});
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = - Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    // Player and enemies setup
    class Player {
      constructor(id, isLocal = false){
        this.id = id;
        this.isLocal = isLocal;
        this.position = new THREE.Vector3(
          Math.random()*10 - 5,
          1,
          Math.random()*10 - 5
        );
        this.box = new THREE.Mesh(
          new THREE.BoxGeometry(1, 2, 1),
          new THREE.MeshBasicMaterial({color: isLocal ? 0x00ff00 : 0xff0000, wireframe: false})
        );
        this.box.position.copy(this.position);
        scene.add(this.box);
        this.health = 100;
      }

      update(){
        this.box.position.copy(this.position);
      }
    }

    const localPlayer = new Player('local', true);
    const enemies = [];

    // Generate some dummy enemies for demo
    for(let i=0; i<5; i++){
      enemies.push(new Player('enemy'+i));
    }

    // Raycaster for aiming
    const raycaster = new THREE.Raycaster();

    // Mod States
    let mods = {
      aimbot: false,
      triggerbot: false,
      homing: false,
      esp: false,
      tracer: false
    };

    // UI toggles
    document.getElementById('aimbotToggle').onclick = () => {
      mods.aimbot = !mods.aimbot;
      updateToggle('aimbotToggle', mods.aimbot);
    };
    document.getElementById('triggerbotToggle').onclick = () => {
      mods.triggerbot = !mods.triggerbot;
      updateToggle('triggerbotToggle', mods.triggerbot);
    };
    document.getElementById('homingToggle').onclick = () => {
      mods.homing = !mods.homing;
      updateToggle('homingToggle', mods.homing);
    };
    document.getElementById('espToggle').onclick = () => {
      mods.esp = !mods.esp;
      updateToggle('espToggle', mods.esp);
    };
    document.getElementById('tracerToggle').onclick = () => {
      mods.tracer = !mods.tracer;
      updateToggle('tracerToggle', mods.tracer);
    };

    function updateToggle(id, state){
      const el = document.getElementById(id);
      el.textContent = el.textContent.split(':')[0] + ': ' + (state ? 'ON' : 'OFF');
      if(state) el.classList.add('active');
      else el.classList.remove('active');
    }

    // Bullet class for homing bullets
    class Bullet {
      constructor(position, direction, homingTarget = null){
        this.position = position.clone();
        this.direction = direction.clone().normalize();
        this.speed = 0.3;
        this.homingTarget = homingTarget; // Player instance
        this.mesh = new THREE.Mesh(
          new THREE.SphereGeometry(0.1, 8, 8),
          new THREE.MeshBasicMaterial({color: 0xffff00})
        );
        this.mesh.position.copy(this.position);
        scene.add(this.mesh);
        this.alive = true;
      }

      update(){
        if(this.homingTarget && this.homingTarget.health > 0){
          // Adjust direction to target
          const targetDir = this.homingTarget.position.clone().sub(this.position).normalize();
          this.direction.lerp(targetDir, 0.1).normalize();
        }
        this.position.add(this.direction.clone().multiplyScalar(this.speed));
        this.mesh.position.copy(this.position);

        // Simple collision check with target (distance)
        if(this.homingTarget && this.position.distanceTo(this.homingTarget.position) < 1){
          this.homingTarget.health -= 10;
          this.alive = false;
          scene.remove(this.mesh);
        }

        // Remove bullet if out of bounds
        if(this.position.length() > 100){
          this.alive = false;
          scene.remove(this.mesh);
        }
      }
    }

    const bullets = [];

    // Shoot bullet function
    function shootBullet(direction, homingTarget=null){
      const startPos = localPlayer.position.clone().add(new THREE.Vector3(0,1,0));
      bullets.push(new Bullet(startPos, direction, homingTarget));
    }

    // Aimbot: find closest enemy to center screen and aim camera at them
    function aimbotUpdate(){
      if(!mods.aimbot) return;

      // Project enemies to screen and find closest to center
      let closestEnemy = null;
      let closestDist = Infinity;
      for(let enemy of enemies){
        if(enemy.health <= 0) continue;
        const pos = enemy.position.clone();
        const screenPos = pos.clone().project(camera);

        const distToCenter = Math.hypot(screenPos.x, screenPos.y);
        if(distToCenter < closestDist){
          closestDist = distToCenter;
          closestEnemy = enemy;
        }
      }
      if(closestEnemy){
        // Rotate camera/controls to face enemy position
        const enemyPos = closestEnemy.position.clone().add(new THREE.Vector3(0,1,0));
        controls.getObject().lookAt(enemyPos);
      }
    }

    // Triggerbot: auto shoot when enemy is under crosshair
    function triggerbotUpdate(){
      if(!mods.triggerbot) return;

      // Raycast from camera forward
      raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
      const intersects = enemies.filter(e => e.health>0).map(enemy => {
        const box = new THREE.Box3().setFromObject(enemy.box);
        return {enemy, distance: raycaster.ray.origin.distanceTo(enemy.position)};
      });

      if(intersects.length === 0) return;

      // Simple closest enemy under crosshair
      let minDist = Infinity;
      let target = null;
      for(let e of enemies){
        if(e.health <= 0) continue;
        // Project enemy position to screen coords
        const screenPos = e.position.clone().project(camera);
        const dx = screenPos.x;
        const dy = screenPos.y;
        const distanceFromCenter = Math.sqrt(dx*dx + dy*dy);
        if(distanceFromCenter < 0.02){ // close enough to center crosshair
          if(distanceFromCenter < minDist){
            minDist = distanceFromCenter;
            target = e;
          }
        }
      }
      if(target){
        // Shoot bullet towards target
        const dir = target.position.clone().sub(localPlayer.position).normalize();
        shootBullet(dir, mods.homing ? target : null);
      }
    }

    // Homing bullets are handled inside bullet update

    // 2D ESP boxes drawing using canvas overlay
    const espCanvas = document.createElement('canvas');
    espCanvas.style.position = 'fixed';
    espCanvas.style.top = '0';
    espCanvas.style.left = '0';
    espCanvas.style.pointerEvents = 'none';
    espCanvas.width = window.innerWidth;
    espCanvas.height = window.innerHeight;
    espCanvas.style.zIndex = '10001';
    document.body.appendChild(espCanvas);
    const espCtx = espCanvas.getContext('2d');

    // Tracer lines drawing on canvas
    // We'll draw lines from screen center to enemy screen pos

    function drawESP(){
      espCtx.clearRect(0, 0, espCanvas.width, espCanvas.height);
      if(!mods.esp && !mods.tracer) return;

      const centerX = espCanvas.width/2;
      const centerY = espCanvas.height/2;

      for(let enemy of enemies){
        if(enemy.health <= 0) continue;

        // Project enemy pos to screen coords
        const pos = enemy.position.clone().project(camera);

        // Convert from NDC to screen pixels
        const x = (pos.x + 1) / 2 * espCanvas.width;
        const y = (-pos.y + 1) / 2 * espCanvas.height;

        if(pos.z < 1){
          if(mods.esp){
            // Draw 2D green box (simple rectangle around enemy)
            const boxWidth = 40;
            const boxHeight = 80;
            espCtx.strokeStyle = 'lime';
            espCtx.lineWidth = 2;
            espCtx.strokeRect(x - boxWidth/2, y - boxHeight, boxWidth, boxHeight);
          }
          if(mods.tracer){
            // Draw red tracer line from center crosshair to enemy
            espCtx.strokeStyle = 'red';
            espCtx.lineWidth = 1;
            espCtx.beginPath();
            espCtx.moveTo(centerX, centerY);
            espCtx.lineTo(x, y);
            espCtx.stroke();
          }
        }
      }
    }

    // Game Loop
    function animate(){
      requestAnimationFrame(animate);

      aimbotUpdate();
      triggerbotUpdate();

      bullets.forEach((bullet, i) => {
        bullet.update();
        if(!bullet.alive) bullets.splice(i,1);
      });

      enemies.forEach(enemy => enemy.update());
      localPlayer.update();

      drawESP();

      renderer.render(scene, camera);
    }
    animate();

    // Window resize handler
    window.addEventListener('resize', () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();

      espCanvas.width = window.innerWidth;
      espCanvas.height = window.innerHeight;
    });

  </script>
</body>
</html>

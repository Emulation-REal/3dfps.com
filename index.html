<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D FPS Game</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }

    #hud, #crosshair {
      position: absolute;
      font-family: sans-serif;
      color: white;
      z-index: 10;
    }

    #hud {
      top: 10px; left: 10px;
      font-size: 18px;
    }

    #crosshair {
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 12px;
      pointer-events: none;
      z-index: 20;
    }

    #status {
      position: absolute;
      top: 10px; right: 10px;
      font-family: monospace;
      color: yellow;
      z-index: 20;
      background: rgba(0,0,0,0.6);
      padding: 5px 10px;
      border-radius: 5px;
    }
  </style>
</head>
<body>
  <div id="hud">Health: <span id="health">100</span></div>
  <div id="crosshair">+</div>
  <div id="status">Connecting...</div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.125.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.125.2/examples/js/controls/PointerLockControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/peerjs@1.4.7/dist/peerjs.min.js"></script>

  <script>
    // --- THREE.JS SETUP ---
    let scene = new THREE.Scene();
    let camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    let renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    let controls = new THREE.PointerLockControls(camera, document.body);
    document.body.addEventListener('click', () => {
      controls.lock();
    });
    scene.add(controls.getObject());

    let health = 100;
    const healthDisplay = document.getElementById("health");
    const statusDisplay = document.getElementById("status");

    // Movement controls
    const keys = {};
    document.addEventListener('keydown', e => keys[e.code] = true);
    document.addEventListener('keyup', e => keys[e.code] = false);

    // Ground
    const floor = new THREE.Mesh(
      new THREE.PlaneGeometry(200, 200),
      new THREE.MeshStandardMaterial({ color: 0x333333 })
    );
    floor.rotation.x = -Math.PI / 2;
    scene.add(floor);

    // Light
    scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1));

    // Obstacles
    const obstacles = [];
    for (let i = 0; i < 15; i++) {
      const o = new THREE.Mesh(
        new THREE.BoxGeometry(5, 6, 2),
        new THREE.MeshStandardMaterial({ color: 0x888888 })
      );
      o.position.set((Math.random() - 0.5) * 100, 3, (Math.random() - 0.5) * 100);
      scene.add(o);
      obstacles.push(o);
    }

    // Helper function for collision
    function collides(pos) {
      for (let o of obstacles) {
        const dx = Math.abs(pos.x - o.position.x);
        const dz = Math.abs(pos.z - o.position.z);
        if (dx < 3 && dz < 3) return true;
      }
      return false;
    }

    // Player state
    camera.position.set(0, 1.6, 0);

    // Multiplayer setup

    // We'll keep track of remote players here:
    const remotePlayers = {}; // key: peerId, value: { mesh, position, lastUpdate }

    // Create a mesh for the local player (invisible since camera is first-person)
    // Remote players will be shown as boxes:
    function createRemotePlayerMesh() {
      return new THREE.Mesh(
        new THREE.BoxGeometry(1, 2, 1),
        new THREE.MeshStandardMaterial({ color: 0x0000ff })
      );
    }

    // --- PEERJS SETUP ---
    // Use a fixed room ID so everyone joins the same room
    const ROOM_ID = "shared-game-room";

    // Create Peer with fixed ID (so everyone tries to connect to same ID)
    // To avoid conflicts, we'll try ROOM_ID + random suffix for host or "client" mode
    let peer = null;
    let connections = {};
    let isHost = false;

    // We'll start as host first (try to create peer with ROOM_ID)
    // If ID taken, fallback to client mode with random ID and connect to ROOM_ID
    function startPeer() {
      peer = new Peer(ROOM_ID, {
        debug: 2
      });

      peer.on('open', id => {
        console.log('Peer open with ID:', id);
        statusDisplay.textContent = "Connected as host (" + id + ")";
        isHost = true;
      });

      peer.on('error', err => {
        console.log('Peer error:', err);
        if (err.type === 'unavailable-id') {
          // ROOM_ID already taken, become client with random ID
          startClientPeer();
        } else {
          statusDisplay.textContent = "Peer error: " + err.type;
        }
      });

      peer.on('connection', conn => {
        console.log('New peer connected to host:', conn.peer);
        setupConnectionHandlers(conn);
      });
    }

    // Start client peer with random ID and connect to host ROOM_ID
    function startClientPeer() {
      peer = new Peer({
        debug: 2
      });
      peer.on('open', id => {
        console.log('Client peer open with ID:', id);
        statusDisplay.textContent = "Connected as client (" + id + ")";
        connectToHost();
      });

      peer.on('error', err => {
        console.log('Client peer error:', err);
        statusDisplay.textContent = "Peer error: " + err.type;
      });

      peer.on('connection', conn => {
        console.log('Client got connection from:', conn.peer);
        setupConnectionHandlers(conn);
      });
    }

    // Client connects to host peer ROOM_ID
    function connectToHost() {
      let conn = peer.connect(ROOM_ID);
      conn.on('open', () => {
        console.log('Connected to host:', ROOM_ID);
        statusDisplay.textContent = "Connected to host";
        setupConnectionHandlers(conn);
      });
      conn.on('error', err => {
        console.log('Connection error:', err);
        statusDisplay.textContent = "Connection error";
      });
    }

    // Setup data handlers for a connection
    function setupConnectionHandlers(conn) {
      connections[conn.peer] = conn;

      conn.on('data', data => {
        // Data from remote peer
        if (data.type === 'position') {
          // Update or create remote player
          let rp = remotePlayers[conn.peer];
          if (!rp) {
            // New remote player
            const mesh = createRemotePlayerMesh();
            scene.add(mesh);
            remotePlayers[conn.peer] = { mesh, lastUpdate: Date.now() };
          }
          let player = remotePlayers[conn.peer];
          player.mesh.position.set(data.x, data.y, data.z);
          player.lastUpdate = Date.now();
        }
      });

      conn.on('close', () => {
        console.log('Connection closed:', conn.peer);
        // Remove remote player
        if (remotePlayers[conn.peer]) {
          scene.remove(remotePlayers[conn.peer].mesh);
          delete remotePlayers[conn.peer];
        }
        delete connections[conn.peer];
      });
    }

    // Start PeerJS
    startPeer();

    // --- GAME LOOP ---
    const direction = new THREE.Vector3();

    function animate() {
      requestAnimationFrame(animate);

      // Movement
      direction.set(0, 0, 0);
      if (keys['KeyW']) direction.z -= 1;
      if (keys['KeyS']) direction.z += 1;
      if (keys['KeyA']) direction.x -= 1;
      if (keys['KeyD']) direction.x += 1;

      direction.normalize().applyQuaternion(camera.quaternion);
      direction.y = 0;

      let speed = 0.2;
      let nextPos = controls.getObject().position.clone().add(direction.multiplyScalar(speed));
      if (!collides(nextPos)) controls.getObject().position.copy(nextPos);

      controls.getObject().position.y -= 0.2;
      if (controls.getObject().position.y < 1.6) controls.getObject().position.y = 1.6;

      // Send position to all peers
      const pos = controls.getObject().position;
      for (let peerId in connections) {
        let conn = connections[peerId];
        if (conn.open) {
          conn.send({
            type: 'position',
            x: pos.x,
            y: pos.y,
            z: pos.z
          });
        }
      }

      // Remove inactive remote players (timeout 10 sec)
      let now = Date.now();
      for (let peerId in remotePlayers) {
        if (now - remotePlayers[peerId].lastUpdate > 10000) {
          scene.remove(remotePlayers[peerId].mesh);
          delete remotePlayers[peerId];
          if (connections[peerId]) {
            connections[peerId].close();
            delete connections[peerId];
          }
        }
      }

      // Update health display (just static for now)
      healthDisplay.textContent = Math.floor(health);

      renderer.render(scene, camera);
    }

    animate();

    // Resize handler
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Multiplayer FPS Game â€“ Color-Enhanced Map + Chat + Mods</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #hud, #crosshair, #status, #playerList, #chat, #chatInput, #modMenu {
      position: absolute;
      font-family: sans-serif;
      z-index: 10;
    }
    #hud {
      top: 10px; left: 10px;
      font-size: 16px;
      color: white;
    }
    #crosshair {
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      font-size: 14px;
      color: white;
      pointer-events: none;
    }
    #status {
      top: 10px; right: 10px;
      font-size: 14px;
      color: yellow;
      background: rgba(0, 0, 0, 0.5);
      padding: 6px;
      border-radius: 6px;
    }
    #playerList {
      top: 50px; right: 10px;
      color: lightgreen;
      font-size: 13px;
      background: rgba(0, 0, 0, 0.5);
      padding: 5px;
      border-radius: 6px;
      max-width: 150px;
    }
    #chat {
      bottom: 10px; left: 10px;
      width: 300px;
      max-height: 150px;
      overflow-y: auto;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 8px;
      border-radius: 6px;
      font-size: 14px;
      user-select: none;
    }
    #chatInput {
      bottom: 170px; left: 10px;
      width: 300px;
      display: none;
      font-size: 14px;
      padding: 6px;
      border-radius: 6px;
      border: none;
      outline: none;
      background: rgba(255,255,255,0.9);
      color: black;
    }
    #modMenu {
      top: 100px; left: 10px;
      width: 160px;
      background: rgba(20, 20, 20, 0.85);
      border: 2px solid #0088ff;
      border-radius: 8px;
      padding: 10px;
      color: white;
      display: none;
      user-select: none;
      font-size: 14px;
      box-shadow: 0 0 10px #0088ff;
    }
    #modMenu label {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
      cursor: pointer;
    }
    #modMenu input[type=checkbox] {
      margin-right: 8px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="hud">Health: <span id="health">100</span></div>
  <div id="crosshair">+</div>
  <div id="status">Connecting...</div>
  <div id="playerList">Players:<br/></div>
  <div id="chat"></div>
  <input id="chatInput" type="text" placeholder="Type your message and press Enter..." />

  <!-- Mod Menu -->
  <div id="modMenu">
    <label><input type="checkbox" id="modEsp">ESP</label>
    <label><input type="checkbox" id="modTracers">Tracers</label>
    <label><input type="checkbox" id="modAimbot">Aimbot (hold RMB)</label>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.125.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.125.2/examples/js/controls/PointerLockControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/peerjs@1.4.7/dist/peerjs.min.js"></script>

  <script>
    // === Initialization ===
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new THREE.PointerLockControls(camera, document.body);
    document.body.addEventListener('click', () => controls.lock());
    scene.add(controls.getObject());

    let health = 100;
    let isDead = false;
    const healthDisplay = document.getElementById("health");
    const statusDisplay = document.getElementById("status");
    const playerListDisplay = document.getElementById("playerList");
    const chatDisplay = document.getElementById("chat");
    const chatInput = document.getElementById("chatInput");

    const modMenu = document.getElementById("modMenu");
    const modEspCheckbox = document.getElementById("modEsp");
    const modTracersCheckbox = document.getElementById("modTracers");
    const modAimbotCheckbox = document.getElementById("modAimbot");

    let keys = {};
    let mods = {
      esp: false,
      tracers: false,
      aimbot: false,
    };

    // Mod toggles
    modEspCheckbox.addEventListener('change', e => mods.esp = e.target.checked);
    modTracersCheckbox.addEventListener('change', e => mods.tracers = e.target.checked);
    modAimbotCheckbox.addEventListener('change', e => mods.aimbot = e.target.checked);

    document.addEventListener('keydown', e => {
      keys[e.code] = true;

      if (e.key === ';') {
        e.preventDefault();
        modMenu.style.display = (modMenu.style.display === "block") ? "none" : "block";
      }

      // Chat toggle logic
      if (e.key === '/') {
        e.preventDefault();
        if (!chatInput.style.display || chatInput.style.display === "none") {
          chatInput.style.display = "block";
          chatInput.focus();
        }
      } else if (e.key === "Escape") {
        if (chatInput.style.display === "block") {
          chatInput.value = "";
          chatInput.style.display = "none";
          controls.lock();
        }
      }
    });
    document.addEventListener('keyup', e => keys[e.code] = false);

    // Disable movement keys while typing
    chatInput.addEventListener('keydown', e => {
      if (e.key === 'Enter') {
        const msg = chatInput.value.trim();
        if (msg) sendChatMessage(msg);
        chatInput.value = '';
        chatInput.style.display = "none";
        controls.lock();
      }
      e.stopPropagation();
    });

    // Lighting
    scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1));
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(5, 10, 7);
    scene.add(dirLight);

    // Floor and obstacles
    const floor = new THREE.Mesh(
      new THREE.PlaneGeometry(200, 200),
      new THREE.MeshStandardMaterial({ color: 0x888877 })
    );
    floor.rotation.x = -Math.PI / 2;
    scene.add(floor);

    const containerColors = [0x0055ff, 0xff3333, 0x33cc33, 0xffff33];
    const obstacles = [];
    for (let i = 0; i < 15; i++) {
      const color = containerColors[i % containerColors.length];
      const box = new THREE.Mesh(
        new THREE.BoxGeometry(5, 6, 2),
        new THREE.MeshStandardMaterial({ color })
      );
      box.position.set((Math.random() - 0.5) * 100, 3, (Math.random() - 0.5) * 100);
      scene.add(box);
      obstacles.push(box);
    }

    function collides(pos) {
      for (let o of obstacles) {
        if (Math.abs(pos.x - o.position.x) < 3
         && Math.abs(pos.z - o.position.z) < 3) return true;
      }
      return false;
    }

    camera.position.set(0, 2, 10);
    controls.getObject().position.set(0, 1.6, 10);

    // === Multiplayer Setup ===
    const ROOM_ID = "shared-room";
    let peer, isHost = false;
    const connections = {};
    const remotePlayers = {};

    function updatePlayerList() {
      let html = "Players:<br/>You<br/>";
      for (const id in remotePlayers) html += id + "<br/>";
      playerListDisplay.innerHTML = html;
    }

    function createRemoteMesh() {
      return new THREE.Mesh(
        new THREE.BoxGeometry(1, 2, 1),
        new THREE.MeshStandardMaterial({ color: 0x0000ff })
      );
    }

    function addChatMessage(sender, message) {
      const div = document.createElement('div');
      div.textContent = sender + ": " + message;
      chatDisplay.appendChild(div);
      chatDisplay.scrollTop = chatDisplay.scrollHeight;
    }

    function setupConnection(conn) {
      connections[conn.peer] = conn;

      conn.on('data', data => {
        if (data.type === 'position') {
          if (!remotePlayers[conn.peer]) {
            const mesh = createRemoteMesh();
            scene.add(mesh);
            remotePlayers[conn.peer] = { mesh, health: 100 };
            updatePlayerList();
          }
          remotePlayers[conn.peer].mesh.position.set(data.x, data.y, data.z);
        }
        else if (data.type === 'hit') {
          if (!isDead) {
            health -= 25;
            if (health <= 0) dieAndRespawn();
          }
        }
        else if (data.type === 'chat') {
          addChatMessage(conn.peer, data.message);
        }
      });

      conn.on('close', () => {
        if (remotePlayers[conn.peer]) {
          scene.remove(remotePlayers[conn.peer].mesh);
          delete remotePlayers[conn.peer];
          updatePlayerList();
        }
        delete connections[conn.peer];
      });
    }

    function startPeerAsHost() {
      peer = new Peer(ROOM_ID, { debug: 1 });
      peer.on('open', () => {
        statusDisplay.textContent = "Connected as Host";
        isHost = true;
      });
      peer.on('connection', conn => setupConnection(conn));
      peer.on('error', err => {
        if (err.type === 'unavailable-id') startPeerAsClient();
      });
    }

    function startPeerAsClient() {
      peer = new Peer({ debug: 1 });
      peer.on('open', () => {
        statusDisplay.textContent = "Connected as Client";
        const conn = peer.connect(ROOM_ID);
        conn.on('open', () => setupConnection(conn));
      });
    }

    startPeerAsHost();

    function sendChatMessage(message) {
      addChatMessage("You", message);
      for (const id in connections) {
        const conn = connections[id];
        if (conn.open) conn.send({ type: 'chat', message });
      }
    }

    // === Shooting ===
    const bullets = [];
    document.addEventListener('click', () => {
      if (isDead) return;
      if (chatInput.style.display === "block") return;

      const bullet = new THREE.Mesh(
        new THREE.SphereGeometry(0.1),
        new THREE.MeshBasicMaterial({ color: 0xff0000 })
      );
      bullet.position.copy(camera.position);
      bullet.direction = camera.getWorldDirection(new THREE.Vector3()).clone();
      scene.add(bullet);
      bullets.push(bullet);
    });

    function checkBulletHit(bullet) {
      for (const id in remotePlayers) {
        const player = remotePlayers[id];
        if (bullet.position.distanceTo(player.mesh.position) < 1.5) {
          connections[id]?.send({ type: 'hit' });
          return true;
        }
      }
      return false;
    }

    function dieAndRespawn() {
      isDead = true;
      health = 0;
      healthDisplay.textContent = "DEAD";
      controls.getObject().position.set(999, 999, 999);

      setTimeout(() => {
        isDead = false;
        health = 100;
        healthDisplay.textContent = health;
        controls.getObject().position.set(Math.random() * 20 - 10, 1.6, Math.random() * 20 - 10);
      }, 3000);
    }

    // === Mods ===
    const tracerLines = [];
    const espBoxes = [];

    function updateESP() {
      tracerLines.forEach(l => scene.remove(l));
      espBoxes.forEach(b => scene.remove(b));
      tracerLines.length = 0;
      espBoxes.length = 0;

      for (const id in remotePlayers) {
        const enemy = remotePlayers[id];

        if (mods.tracers) {
          const origin = controls.getObject().position.clone();
          const target = enemy.mesh.position.clone().add(new THREE.Vector3(0, 1, 0)); // torso height
          const geometry = new THREE.BufferGeometry().setFromPoints([origin, target]);
          const line = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 0xffff00 }));
          tracerLines.push(line);
          scene.add(line);
        }

        if (mods.esp) {
          const bbox = new THREE.Box3().setFromObject(enemy.mesh);
          const size = new THREE.Vector3();
          bbox.getSize(size);
          const center = new THREE.Vector3();
          bbox.getCenter(center);

          const boxGeo = new THREE.BoxGeometry(size.x, size.y, size.z);
          const wireMat = new THREE.MeshBasicMaterial({ color: 0xff00ff, wireframe: true });
          const box = new THREE.Mesh(boxGeo, wireMat);
          box.position.copy(center);
          espBoxes.push(box);
          scene.add(box);
        }
      }
    }

    function getClosestEnemy() {
      let minDist = Infinity;
      let closest = null;
      const playerPos = controls.getObject().position;
      for (const id in remotePlayers) {
        const enemy = remotePlayers[id];
        const dist = playerPos.distanceTo(enemy.mesh.position);
        if (dist < minDist) {
          minDist = dist;
          closest = enemy;
        }
      }
      return closest;
    }

    // For aimbot: smoothly rotate camera toward enemy while RMB held
    let aiming = false;
    document.addEventListener('mousedown', e => {
      if (e.button === 2) aiming = true; // right mouse button
    });
    document.addEventListener('mouseup', e => {
      if (e.button === 2) aiming = false;
    });

    function updateAimbot() {
      if (!mods.aimbot || !aiming || isDead) return;

      const target = getClosestEnemy();
      if (!target) return;

      const playerPos = controls.getObject().position.clone();
      const enemyPos = target.mesh.position.clone().add(new THREE.Vector3(0, 1, 0));

      const dir = enemyPos.clone().sub(playerPos).normalize();

      // Calculate target rotation for the camera
      const targetYaw = Math.atan2(dir.x, dir.z);
      const targetPitch = Math.asin(dir.y);

      // Current rotation (camera.rotation is in Euler angles)
      let currentYaw = controls.getObject().rotation.y;
      let currentPitch = camera.rotation.x;

      // Normalize angles between -PI and PI for smooth rotation
      function normalizeAngle(a) {
        while (a > Math.PI) a -= Math.PI * 2;
        while (a < -Math.PI) a += Math.PI * 2;
        return a;
      }

      currentYaw = normalizeAngle(currentYaw);
      currentPitch = normalizeAngle(currentPitch);

      // Lerp rotation to target (smooth)
      const lerpFactor = 0.15;
      let newYaw = currentYaw + (targetYaw - currentYaw) * lerpFactor;
      let newPitch = currentPitch + (targetPitch - currentPitch) * lerpFactor;

      // Clamp pitch so camera doesn't flip
      const maxPitch = Math.PI / 2 - 0.01;
      const minPitch = -maxPitch;
      newPitch = Math.min(maxPitch, Math.max(minPitch, newPitch));

      controls.getObject().rotation.y = newYaw;
      camera.rotation.x = newPitch;
    }

    // === Main Loop ===
    const dirVec = new THREE.Vector3();

    function animate() {
      requestAnimationFrame(animate);

      if (!isDead && chatInput.style.display !== "block") {
        dirVec.set(0, 0, 0);
        if (keys.KeyW) dirVec.z -= 1;
        if (keys.KeyS) dirVec.z += 1;
        if (keys.KeyA) dirVec.x -= 1;
        if (keys.KeyD) dirVec.x += 1;
        dirVec.normalize().applyQuaternion(camera.quaternion);
        dirVec.y = 0;

        const nextPos = controls.getObject().position.clone().add(dirVec.multiplyScalar(0.2));
        if (!collides(nextPos)) controls.getObject().position.copy(nextPos);

        for (const id in connections) {
          const conn = connections[id];
          if (conn.open) {
            const p = controls.getObject().position;
            conn.send({ type: 'position', x: p.x, y: p.y, z: p.z });
          }
        }
      }

      bullets.forEach((b, i) => {
        b.position.add(b.direction.clone().multiplyScalar(0.5));
        if (checkBulletHit(b)) {
          scene.remove(b); bullets.splice(i, 1);
        }
        else if (b.position.length() > 200) {
          scene.remove(b); bullets.splice(i, 1);
        }
      });

      updateESP();
      updateAimbot();

      healthDisplay.textContent = isDead ? "DEAD" : Math.floor(health);
      renderer.render(scene, camera);
    }

    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Context menu disabled (so right-click can be used for aimbot)
    window.addEventListener('contextmenu', e => e.preventDefault());
  </script>
</body>
</html>

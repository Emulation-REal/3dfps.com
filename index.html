<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Multiplayer FPS</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #hud, #crosshair, #status, #playerList, #chatBox, #modMenu {
      position: absolute;
      font-family: sans-serif;
      z-index: 10;
    }
    #hud {
      top: 10px; left: 10px;
      font-size: 16px;
      color: white;
    }
    #crosshair {
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      font-size: 14px;
      color: white;
      pointer-events: none;
    }
    #status {
      top: 10px; right: 10px;
      font-size: 14px;
      color: yellow;
      background: rgba(0, 0, 0, 0.5);
      padding: 6px;
      border-radius: 6px;
    }
    #playerList {
      top: 50px; right: 10px;
      color: lightgreen;
      font-size: 13px;
      background: rgba(0, 0, 0, 0.5);
      padding: 5px;
      border-radius: 6px;
      max-width: 150px;
    }
    #chatBox {
      bottom: 10px;
      left: 10px;
      color: white;
      width: 300px;
    }
    #chatMessages {
      background: rgba(0,0,0,0.5);
      max-height: 120px;
      overflow-y: auto;
      font-size: 14px;
      margin-bottom: 4px;
    }
    #chatInput {
      width: 100%;
      font-size: 14px;
      padding: 4px;
      border: none;
      display: none;
    }
    #modMenu {
      display: none;
      top: 100px; right: 20px;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 10px;
      border: 2px solid cyan;
      border-radius: 8px;
      width: 200px;
    }
    #modMenu h3 {
      margin-top: 0;
      font-size: 16px;
      text-align: center;
    }
    .modToggle {
      display: flex;
      justify-content: space-between;
      margin: 5px 0;
    }
  </style>
</head>
<body>
  <div id="hud">Health: <span id="health">100</span></div>
  <div id="crosshair">+</div>
  <div id="status">Connecting...</div>
  <div id="playerList">Players:<br/></div>
  <div id="chatBox">
    <div id="chatMessages"></div>
    <input type="text" id="chatInput" placeholder="Type your message...">
  </div>
  <div id="modMenu">
    <h3>Secret Mod Menu</h3>
    <div class="modToggle"><span>ESP</span><input type="checkbox" id="modESP"></div>
    <div class="modToggle"><span>Tracers</span><input type="checkbox" id="modTracers"></div>
    <div class="modToggle"><span>Aimbot</span><input type="checkbox" id="modAimbot"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.125.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.125.2/examples/js/controls/PointerLockControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/peerjs@1.4.7/dist/peerjs.min.js"></script>

  <script>
    // Core variables
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Controls
    const controls = new THREE.PointerLockControls(camera, document.body);
    document.body.addEventListener('click', () => {
      if (!document.getElementById("chatInput").style.display.includes("block"))
        controls.lock();
    });
    scene.add(controls.getObject());

    const healthDisplay = document.getElementById("health");
    const statusDisplay = document.getElementById("status");
    const playerListDisplay = document.getElementById("playerList");
    const chatMessages = document.getElementById("chatMessages");
    const chatInput = document.getElementById("chatInput");
    const modMenu = document.getElementById("modMenu");
    const modESP = document.getElementById("modESP");
    const modTracers = document.getElementById("modTracers");
    const modAimbot = document.getElementById("modAimbot");

    let keys = {}, isDead = false, velocityY = 0, grounded = true, health = 100;
    document.addEventListener('keydown', e => {
      if (e.key === '/' && chatInput.style.display === 'none') {
        chatInput.style.display = 'block';
        chatInput.focus();
        controls.unlock();
        e.preventDefault();
        return;
      }
      keys[e.code] = true;
    });
    document.addEventListener('keyup', e => keys[e.code] = false);
    chatInput.addEventListener('keydown', e => {
      if (e.key === 'Enter') {
        if (chatInput.value.trim() !== '') {
          appendMessage("You: " + chatInput.value);
          broadcast({ type: "chat", message: chatInput.value });
        }
        chatInput.value = "";
        chatInput.style.display = "none";
      }
    });

    // Floor
    const floor = new THREE.Mesh(
      new THREE.PlaneGeometry(200, 200),
      new THREE.MeshStandardMaterial({ color: 0x888877 })
    );
    floor.rotation.x = -Math.PI / 2;
    scene.add(floor);

    const obstacles = [], colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00];
    for (let i = 0; i < 15; i++) {
      const box = new THREE.Mesh(
        new THREE.BoxGeometry(5, 6, 2),
        new THREE.MeshStandardMaterial({ color: colors[i % 4] })
      );
      box.position.set(Math.random()*100-50, 3, Math.random()*100-50);
      scene.add(box);
      obstacles.push(box);
    }

    // Chat helper
    function appendMessage(text) {
      const msg = document.createElement("div");
      msg.textContent = text;
      chatMessages.appendChild(msg);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    // PeerJS multiplayer
    const ROOM_ID = "shared-room";
    let peer, isHost = false;
    const connections = {}, remotePlayers = {};

    function createRemoteMesh(id) {
      const box = new THREE.Mesh(
        new THREE.BoxGeometry(1, 2, 1),
        new THREE.MeshStandardMaterial({ color: 0x00ffff, transparent: true, opacity: 0.7 })
      );
      box.name = id;
      scene.add(box);
      return box;
    }

    function setupConnection(conn) {
      connections[conn.peer] = conn;
      conn.on('data', data => {
        if (data.type === "position") {
          if (!remotePlayers[conn.peer]) {
            const mesh = createRemoteMesh(conn.peer);
            remotePlayers[conn.peer] = { mesh, health: 100 };
            updatePlayerList();
          }
          remotePlayers[conn.peer].mesh.position.set(data.x, data.y, data.z);
        }
        if (data.type === "hit") {
          if (!isDead) {
            health -= 10;
            if (health <= 0) dieAndRespawn();
          }
        }
        if (data.type === "chat") {
          appendMessage(`${conn.peer}: ${data.message}`);
        }
      });
      conn.on("close", () => {
        if (remotePlayers[conn.peer]) scene.remove(remotePlayers[conn.peer].mesh);
        delete remotePlayers[conn.peer];
        updatePlayerList();
      });
    }

    function broadcast(data) {
      for (const id in connections)
        connections[id].send(data);
    }

    function updatePlayerList() {
      let html = "Players:<br/>You<br/>";
      for (const id in remotePlayers) html += `${id}<br/>`;
      playerListDisplay.innerHTML = html;
    }

    function startPeerAsHost() {
      peer = new Peer(ROOM_ID, { debug: 1 });
      peer.on('open', () => {
        statusDisplay.textContent = "Connected as Host";
        isHost = true;
      });
      peer.on('connection', setupConnection);
      peer.on('error', err => {
        if (err.type === "unavailable-id") startPeerAsClient();
      });
    }

    function startPeerAsClient() {
      peer = new Peer({ debug: 1 });
      peer.on('open', () => {
        statusDisplay.textContent = "Connected as Client";
        const conn = peer.connect(ROOM_ID);
        conn.on('open', () => setupConnection(conn));
      });
    }

    startPeerAsHost();

    // Shooting
    const bullets = [];
    document.addEventListener('mousedown', e => {
      if (e.button === 0 && !isDead) {
        const b = new THREE.Mesh(
          new THREE.SphereGeometry(0.1),
          new THREE.MeshBasicMaterial({ color: 0xff0000 })
        );
        b.position.copy(camera.position);
        b.direction = camera.getWorldDirection(new THREE.Vector3());
        scene.add(b);
        bullets.push(b);
      }
    });

    function dieAndRespawn() {
      isDead = true;
      health = 0;
      healthDisplay.textContent = "DEAD";
      controls.getObject().position.set(999, 999, 999);
      setTimeout(() => {
        isDead = false;
        health = 100;
        controls.getObject().position.set(0, 1.6, 0);
      }, 3000);
    }

    // Jumping + Movement + Mods
    const dirVec = new THREE.Vector3();
    document.addEventListener("keydown", e => {
      if (e.key === ';') modMenu.style.display = modMenu.style.display === "block" ? "none" : "block";
    });

    function animate() {
      requestAnimationFrame(animate);
      if (!isDead) {
        dirVec.set(0, 0, 0);
        if (keys.KeyW) dirVec.z -= 1;
        if (keys.KeyS) dirVec.z += 1;
        if (keys.KeyA) dirVec.x -= 1;
        if (keys.KeyD) dirVec.x += 1;
        dirVec.normalize().applyQuaternion(camera.quaternion);
        dirVec.y = 0;

        const obj = controls.getObject();
        const next = obj.position.clone().add(dirVec.clone().multiplyScalar(0.2));
        if (next.y <= 1.6) {
          next.y = 1.6;
          velocityY = 0;
          grounded = true;
        }

        if (!collides(next)) obj.position.copy(next);

        if (keys.Space && grounded) {
          velocityY = 0.25;
          grounded = false;
        }

        obj.position.y += velocityY;
        velocityY -= 0.01;

        // Send position
        broadcast({ type: 'position', x: obj.position.x, y: obj.position.y, z: obj.position.z });
      }

      // Bullets
      bullets.forEach((b, i) => {
        b.position.add(b.direction.clone().multiplyScalar(0.5));
        for (const id in remotePlayers) {
          if (b.position.distanceTo(remotePlayers[id].mesh.position) < 1.5) {
            connections[id]?.send({ type: "hit" });
            scene.remove(b); bullets.splice(i, 1);
          }
        }
      });

      // ESP/Tracers
      if (modESP.checked || modTracers.checked) {
        for (const id in remotePlayers) {
          const player = remotePlayers[id];
          if (modESP.checked) {
            const label = document.getElementById("esp-" + id) || (() => {
              const lbl = document.createElement("div");
              lbl.id = "esp-" + id;
              lbl.style.position = "absolute";
              lbl.style.color = "red";
              lbl.style.zIndex = "10";
              document.body.appendChild(lbl);
              return lbl;
            })();
            const pos = player.mesh.position.clone().project(camera);
            label.style.left = (pos.x * 0.5 + 0.5) * window.innerWidth + "px";
            label.style.top = (-pos.y * 0.5 + 0.5) * window.innerHeight + "px";
            label.textContent = `${id} (${player.health})`;
          }
        }
      }

      healthDisplay.textContent = isDead ? "DEAD" : Math.floor(health);
      renderer.render(scene, camera);
    }

    function collides(pos) {
      for (let o of obstacles) {
        if (Math.abs(pos.x - o.position.x) < 3 && Math.abs(pos.z - o.position.z) < 3)
          return true;
      }
      return false;
    }

    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>

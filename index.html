<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Multiplayer FPS Game â€“ Mods</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #overlay {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 100;
    }
    #hud, #crosshair, #status, #playerList, #chat, #chatInput {
      position: absolute;
      font-family: sans-serif;
      z-index: 10;
    }
    #hud { top: 10px; left: 10px; font-size: 16px; color: white; }
    #crosshair {
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      font-size: 14px; color: white;
      pointer-events: none;
    }
    #status {
      top: 10px; right: 10px;
      font-size: 14px;
      color: yellow;
      background: rgba(0,0,0,0.5);
      padding: 6px;
      border-radius: 6px;
    }
    #playerList {
      top: 50px; right: 10px;
      color: lightgreen;
      font-size: 13px;
      background: rgba(0,0,0,0.5);
      padding: 5px;
      border-radius: 6px;
      max-width: 150px;
    }
    #chat {
      bottom: 10px; left: 10px;
      width: 300px; max-height: 150px;
      overflow-y: auto;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 8px; border-radius: 6px;
      font-size: 14px; user-select: none;
    }
    #chatInput {
      bottom: 170px; left: 10px;
      width: 300px; display: none;
      font-size: 14px; padding: 6px;
      border-radius: 6px; border: none; outline: none;
      background: rgba(255,255,255,0.9);
      color: black;
    }
  </style>
</head>
<body>
  <div id="hud">Health: <span id="health">100</span></div>
  <div id="crosshair">+</div>
  <div id="status">Connecting...</div>
  <div id="playerList">Players:<br/></div>
  <div id="chat"></div>
  <input id="chatInput" type="text" placeholder="Type your message and press Enter..." />

  <canvas id="overlay"></canvas>
  <script src="https://cdn.jsdelivr.net/npm/three@0.125.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.125.2/examples/js/controls/PointerLockControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/peerjs@1.4.7/dist/peerjs.min.js"></script>
  <script>
    // --- THREE.JS SETUP ---
    const scene    = new THREE.Scene();
    const camera   = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    // Overlay for 2D ESP/Tracers
    const overlay = document.getElementById('overlay');
    overlay.width  = innerWidth;
    overlay.height = innerHeight;
    const octx = overlay.getContext('2d');

    window.addEventListener('resize', () => {
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
      overlay.width  = innerWidth;
      overlay.height = innerHeight;
    });

    // Controls
    const controls = new THREE.PointerLockControls(camera, document.body);
    document.body.addEventListener('click', () => controls.lock());
    scene.add(controls.getObject());

    // Lights
    scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1));
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(5,10,7);
    scene.add(dirLight);

    // Floor
    const floor = new THREE.Mesh(
      new THREE.PlaneGeometry(200,200),
      new THREE.MeshStandardMaterial({ color: 0x888877 })
    );
    floor.rotation.x = -Math.PI/2;
    floor.receiveShadow = true;
    scene.add(floor);

    // Random obstacles
    const containerColors = [0x0055ff,0xff3333,0x33cc33,0xffff33];
    const obstacles = [];
    for (let i=0; i<15; i++) {
      const box = new THREE.Mesh(
        new THREE.BoxGeometry(5,6,2),
        new THREE.MeshStandardMaterial({ color: containerColors[i%4] })
      );
      box.position.set((Math.random()-0.5)*100, 3, (Math.random()-0.5)*100);
      scene.add(box);
      obstacles.push(box);
    }
    function collides(pos) {
      return obstacles.some(o =>
        Math.abs(pos.x - o.position.x) < 3 &&
        Math.abs(pos.z - o.position.z) < 3
      );
    }

    // HUD & Chat elements
    let health = 100, isDead = false;
    const healthDisplay    = document.getElementById("health");
    const statusDisplay    = document.getElementById("status");
    const playerListDisplay= document.getElementById("playerList");
    const chatDisplay      = document.getElementById("chat");
    const chatInput        = document.getElementById("chatInput");
    const keys = {};

    document.addEventListener('keydown', e => {
      keys[e.code] = true;
      if (e.key === '/') {
        e.preventDefault();
        chatInput.style.display = "block";
        chatInput.focus();
      } else if (e.key === 'Escape') {
        chatInput.value = "";
        chatInput.style.display = "none";
        controls.lock();
      }
    });
    document.addEventListener('keyup', e => keys[e.code] = false);

    chatInput.addEventListener('keydown', e => {
      if (e.key === 'Enter') {
        const msg = chatInput.value.trim();
        if (msg) sendChatMessage(msg);
        chatInput.value = '';
        chatInput.style.display = "none";
        controls.lock();
      }
      e.stopPropagation();
    });

    // PEERJS Multiplayer Boilerplate
    const ROOM_ID = "shared-room";
    let peer, isHost = false;
    const connections    = {};
    const remotePlayers  = {};

    function updatePlayerList() {
      let html = "Players:<br/>You<br/>";
      for (let id in remotePlayers) html += id + "<br/>";
      playerListDisplay.innerHTML = html;
    }

    function createRemoteMesh() {
      const group = new THREE.Group();
      const body = new THREE.Mesh(
        new THREE.BoxGeometry(1,2,1),
        new THREE.MeshStandardMaterial({ color: 0x0000ff })
      );
      body.position.y = 1;
      const cone = new THREE.Mesh(
        new THREE.ConeGeometry(0.3,0.7,8),
        new THREE.MeshStandardMaterial({ color: 0xffaa00 })
      );
      cone.position.set(0,2,0.75);
      cone.rotation.x = Math.PI;
      group.add(body, cone);
      return group;
    }

    function addChatMessage(sender, message) {
      const div = document.createElement('div');
      div.textContent = sender + ": " + message;
      chatDisplay.appendChild(div);
      chatDisplay.scrollTop = chatDisplay.scrollHeight;
    }

    function setupConnection(conn) {
      connections[conn.peer] = conn;
      conn.on('data', data => {
        if (data.type === 'position') {
          if (!remotePlayers[conn.peer]) {
            const mesh = createRemoteMesh();
            scene.add(mesh);
            remotePlayers[conn.peer] = { mesh, health:100 };
            updatePlayerList();
          }
          remotePlayers[conn.peer].mesh.position.set(data.x,1,data.z);
          if (data.rotationY!==undefined) remotePlayers[conn.peer].mesh.rotation.y = data.rotationY;
        }
        else if (data.type==='hit') {
          if (!isDead) {
            health -= 25;
            if (health<=0) dieAndRespawn();
          }
        }
        else if (data.type==='chat') {
          addChatMessage(conn.peer, data.message);
        }
      });
      conn.on('close', () => {
        scene.remove(remotePlayers[conn.peer].mesh);
        delete remotePlayers[conn.peer];
        delete connections[conn.peer];
        updatePlayerList();
      });
    }

    function startPeerAsHost() {
      peer = new Peer(ROOM_ID, { debug:1 });
      peer.on('open', () => {
        statusDisplay.textContent = "Connected as Host";
        isHost = true;
      });
      peer.on('connection', conn => setupConnection(conn));
      peer.on('error', err => {
        if (err.type === 'unavailable-id') startPeerAsClient();
      });
    }

    function startPeerAsClient() {
      peer = new Peer({ debug:1 });
      peer.on('open', () => {
        statusDisplay.textContent = "Connected as Client";
        const conn = peer.connect(ROOM_ID);
        conn.on('open', () => setupConnection(conn));
      });
    }

    startPeerAsHost();

    function sendChatMessage(message) {
      addChatMessage("You", message);
      for (let id in connections) {
        if (connections[id].open) connections[id].send({ type:'chat', message });
      }
    }

    // Bullets
    const bullets = [];
    document.addEventListener('click', () => {
      if (isDead|| chatInput.style.display==="block") return;
      const bullet = new THREE.Mesh(
        new THREE.SphereGeometry(0.1),
        new THREE.MeshBasicMaterial({ color:0xff0000 })
      );
      bullet.position.copy(camera.position);
      bullet.direction = camera.getWorldDirection(new THREE.Vector3()).clone();
      scene.add(bullet);
      bullets.push(bullet);
    });
    function checkBulletHit(bullet) {
      for (let id in remotePlayers) {
        if (bullet.position.distanceTo(remotePlayers[id].mesh.position) < 1.5) {
          connections[id]?.send({ type:'hit' });
          return true;
        }
      }
      return false;
    }

    function dieAndRespawn() {
      isDead = true; health = 0;
      healthDisplay.textContent = "DEAD";
      controls.getObject().position.set(999,999,999);
      setTimeout(()=>{
        isDead = false; health = 100;
        healthDisplay.textContent = health;
        controls.getObject().position.set(Math.random()*20-10,1.6,Math.random()*20-10);
      },3000);
    }

    // MOD MENU
    let mods = { tracers:false, aimbot:false, esp:false, triggerbot:false };
    const modMenu = document.createElement("div");
    Object.assign(modMenu.style, {
      position:'absolute', top:'50px', left:'50px',
      background:'rgba(0,0,0,0.8)', color:'white', padding:'10px',
      border:'2px solid white', borderRadius:'8px', zIndex:'99', display:'none'
    });
    modMenu.innerHTML = `
      <strong>Mod Menu</strong><br>
      <label><input type="checkbox" id="espToggle"> ESP (2D Box)</label><br>
      <label><input type="checkbox" id="tracersToggle"> Tracers (Red Line)</label><br>
      <label><input type="checkbox" id="aimbotToggle"> Aimbot (Right Click)</label><br>
      <label><input type="checkbox" id="triggerbotToggle"> Triggerbot</label>
    `;
    document.body.appendChild(modMenu);
    document.getElementById("espToggle").onchange     = e=> mods.esp     = e.target.checked;
    document.getElementById("tracersToggle").onchange = e=> mods.tracers = e.target.checked;
    document.getElementById("aimbotToggle").onchange  = e=> mods.aimbot  = e.target.checked;
    document.getElementById("triggerbotToggle").onchange = e=> mods.triggerbot = e.target.checked;

    document.addEventListener("keydown", e=>{
      if (e.key === ";") modMenu.style.display = modMenu.style.display==="none"?"block":"none";
    });

    // 2D ESP & Tracers
    function updateESPAndTracers() {
      octx.clearRect(0,0,overlay.width,overlay.height);
      if (!mods.esp && !mods.tracers) return;

      const cx = overlay.width/2, cy = overlay.height/2;
      for (let id in remotePlayers) {
        const mesh = remotePlayers[id].mesh;
        const feet = mesh.position.clone();
        const head = feet.clone().add(new THREE.Vector3(0,2,0));

        const ndcFeet = feet.project(camera);
        const ndcHead = head.project(camera);

        // on-screen?
        if (ndcFeet.z < 1 && ndcFeet.z > -1) {
          const sxF = (ndcFeet.x*0.5+0.5)*overlay.width;
          const syF = (-ndcFeet.y*0.5+0.5)*overlay.height;
          const sxH = (ndcHead.x*0.5+0.5)*overlay.width;
          const syH = (-ndcHead.y*0.5+0.5)*overlay.height;

          if (mods.esp) {
            const h = Math.abs(syF - syH);
            const w = h * 0.5;
            octx.strokeStyle = 'lime';
            octx.lineWidth = 2;
            octx.strokeRect(sxF - w/2, syH, w, h);
          }

          if (mods.tracers) {
            const center3D = feet.clone().add(new THREE.Vector3(0,1,0)).project(camera);
            const sxC = (center3D.x*0.5+0.5)*overlay.width;
            const syC = (-center3D.y*0.5+0.5)*overlay.height;
            octx.strokeStyle = 'red';
            octx.lineWidth = 1.5;
            octx.beginPath();
            octx.moveTo(cx, cy);
            octx.lineTo(sxC, syC);
            octx.stroke();
          }
        }
      }
    }

    // Aimbot & Triggerbot helpers
    let isAiming = false, triggerbotCooldown = 0;
    document.addEventListener("mousedown", e=>{ if(e.button===2) isAiming=true; });
    document.addEventListener("mouseup",   e=>{ if(e.button===2) isAiming=false; });

    function getClosestEnemy() {
      let best=null, dMin=Infinity;
      for (let id in remotePlayers) {
        const d = camera.position.distanceTo(remotePlayers[id].mesh.position);
        if (d<dMin) { dMin=d; best=remotePlayers[id]; }
      }
      return best;
    }
    function inCrosshair(enemy) {
      if (!enemy) return false;
      const pos = enemy.mesh.position.clone().add(new THREE.Vector3(0,1,0));
      const v = pos.project(camera);
      return Math.abs(v.x)<=0.05 && Math.abs(v.y)<=0.05;
    }

    // MAIN LOOP
    const dirVec = new THREE.Vector3();
    function animate() {
      requestAnimationFrame(animate);

      // Movement + Jump
      if (!isDead && chatInput.style.display!=="block") {
        dirVec.set(0,0,0);
        if (keys.KeyW) dirVec.z-=1;
        if (keys.KeyS) dirVec.z+=1;
        if (keys.KeyA) dirVec.x-=1;
        if (keys.KeyD) dirVec.x+=1;
        dirVec.normalize().applyQuaternion(camera.quaternion);
        dirVec.y = 0;
        const next = controls.getObject().position.clone().add(dirVec.multiplyScalar(0.2));

        // gravity/jump
        if (keys.Space && !dirVec.jumping) {
          dirVec.jumping=true; dirVec.vy=0.2;
        }
        if (dirVec.jumping) {
          dirVec.vy -= 0.01;
          next.y += dirVec.vy;
          if (next.y <= 1.6) {
            next.y = 1.6; dirVec.jumping=false; dirVec.vy=0;
          }
        }

        if (!collides(next)) controls.getObject().position.copy(next);

        // send position
        for (let id in connections) {
          const c = connections[id];
          if (c.open) {
            const p = controls.getObject().position;
            c.send({ type:'position', x:p.x, y:p.y, z:p.z, rotationY:controls.getObject().rotation.y });
          }
        }
      }

      // bullets
      bullets.forEach((b,i)=>{
        b.position.add(b.direction.clone().multiplyScalar(0.5));
        if (checkBulletHit(b)) {
          scene.remove(b); bullets.splice(i,1);
        } else if (b.position.length()>200) {
          scene.remove(b); bullets.splice(i,1);
        }
      });

      // 2D ESP & Tracers
      updateESPAndTracers();

      // Aimbot
      if (mods.aimbot && isAiming) {
        const target = getClosestEnemy();
        if (target) {
          const tp = target.mesh.position.clone().add(new THREE.Vector3(0,1,0));
          const dir = tp.sub(camera.position).normalize();
          const quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,-1), dir);
          camera.quaternion.slerp(quat, 0.2);
          controls.getObject().quaternion.copy(camera.quaternion);
        }
      }

      // Triggerbot
      if (mods.triggerbot && !isDead && chatInput.style.display!=="block") {
        const t = getClosestEnemy();
        if (t && inCrosshair(t) && triggerbotCooldown===0) {
          // fire
          const bullet = new THREE.Mesh(
            new THREE.SphereGeometry(0.1),
            new THREE.MeshBasicMaterial({ color:0xff0000 })
          );
          bullet.position.copy(camera.position);
          bullet.direction = camera.getWorldDirection(new THREE.Vector3()).clone();
          scene.add(bullet);
          bullets.push(bullet);
          triggerbotCooldown = 20;
        }
      }
      if (triggerbotCooldown>0) triggerbotCooldown--;

      renderer.render(scene, camera);
      healthDisplay.textContent = isDead ? "DEAD" : health;
    }
    animate();
  </script>
</body>
</html>

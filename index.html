<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Multiplayer FPS Game â€“ Gamepad Fixes</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #hud, #crosshair, #status, #playerList, #chat, #chatInput {
      position: absolute;
      font-family: sans-serif;
      z-index: 10;
    }
    #hud { top: 10px; left: 10px; font-size: 16px; color: white; }
    #crosshair { top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 14px; color: white; pointer-events: none; }
    #status { top: 10px; right: 10px; font-size: 14px; color: yellow; background: rgba(0,0,0,0.5); padding: 6px; border-radius: 6px; }
    #playerList { top: 50px; right: 10px; color: lightgreen; font-size: 13px; background: rgba(0,0,0,0.5); padding: 5px; border-radius: 6px; max-width: 150px; }
    #chat { bottom: 10px; left: 10px; width: 300px; max-height: 150px; overflow-y: auto; background: rgba(0,0,0,0.7); color: white; padding: 8px; border-radius: 6px; font-size: 14px; user-select: none; }
    #chatInput { bottom: 170px; left: 10px; width: 300px; display: none; font-size: 14px; padding: 6px; border-radius: 6px; border: none; outline: none; background: rgba(255,255,255,0.9); color: black; }
  </style>
</head>
<body>
  <div id="hud">Health: <span id="health">100</span></div>
  <div id="crosshair">+</div>
  <div id="status">Connecting...</div>
  <div id="playerList">Players:<br/></div>
  <div id="chat"></div>
  <input id="chatInput" type="text" placeholder="Type your message and press Enter..." />

  <script src="https://cdn.jsdelivr.net/npm/three@0.125.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.125.2/examples/js/controls/PointerLockControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/peerjs@1.4.7/dist/peerjs.min.js"></script>

  <script>
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new THREE.PointerLockControls(camera, document.body);
    document.body.addEventListener('click', () => controls.lock());
    scene.add(controls.getObject());

    let health = 100, isDead = false;
    const healthDisplay = document.getElementById("health");
    const statusDisplay = document.getElementById("status");
    const playerListDisplay = document.getElementById("playerList");
    const chatDisplay = document.getElementById("chat");
    const chatInput = document.getElementById("chatInput");
    const keys = {};

    document.addEventListener('keydown', e => {
      keys[e.code] = true;
      if (e.key === '/') { e.preventDefault(); chatInput.style.display = "block"; chatInput.focus(); }
      else if (e.key === 'Escape') { chatInput.value = ""; chatInput.style.display = "none"; controls.lock(); }
    });
    document.addEventListener('keyup', e => keys[e.code] = false);
    chatInput.addEventListener('keydown', e => {
      if (e.key === 'Enter') {
        const msg = chatInput.value.trim();
        if (msg) sendChatMessage(msg);
        chatInput.value = '';
        chatInput.style.display = 'none';
        controls.lock();
      }
      e.stopPropagation();
    });

    scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1));
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(5,10,7);
    scene.add(dirLight);

    const floor = new THREE.Mesh(new THREE.PlaneGeometry(200,200), new THREE.MeshStandardMaterial({ color: 0x888877 }));
    floor.rotation.x = -Math.PI/2;
    floor.receiveShadow = true;
    scene.add(floor);

    const containerColors = [0x0055ff, 0xff3333, 0x33cc33, 0xffff33];
    const obstacles = [];
    for (let i=0; i<15; i++) {
      const box = new THREE.Mesh(new THREE.BoxGeometry(5,6,2), new THREE.MeshStandardMaterial({ color: containerColors[i % containerColors.length]}));
      box.position.set((Math.random()-0.5)*100, 3, (Math.random()-0.5)*100);
      box.castShadow = box.receiveShadow = true;
      scene.add(box);
      obstacles.push(box);
    }

    function collides(pos) {
      return obstacles.some(o => Math.abs(pos.x - o.position.x) < 3 && Math.abs(pos.z - o.position.z) < 3);
    }

    camera.position.set(0,2,10);
    controls.getObject().position.set(0,1.6,10);

    const ROOM_ID = "shared-room";
    let peer, isHost = false;
    const connections = {}, remotePlayers = {};

    function updatePlayerList() {
      let html = "Players:<br/>You<br/>";
      for (let id in remotePlayers) html += id + "<br/>";
      playerListDisplay.innerHTML = html;
    }

    function createRemoteMesh() {
      const group = new THREE.Group();
      const body = new THREE.Mesh(new THREE.BoxGeometry(1,2,1), new THREE.MeshStandardMaterial({ color: 0x0000ff }));
      body.position.y = 1;
      const cone = new THREE.Mesh(new THREE.ConeGeometry(0.3,0.7,8), new THREE.MeshStandardMaterial({ color: 0xffaa00 }));
      cone.position.set(0,2,0.75);
      cone.rotation.x = Math.PI;
      group.add(body, cone);
      return group;
    }

    function addChatMessage(sender, msg) {
      const d = document.createElement('div');
      d.textContent = sender + ": " + msg;
      chatDisplay.appendChild(d);
      chatDisplay.scrollTop = chatDisplay.scrollHeight;
    }

    function setupConnection(conn) {
      connections[conn.peer] = conn;
      conn.on('data', data => {
        if (data.type === 'position') {
          if (!remotePlayers[conn.peer]) {
            const mesh = createRemoteMesh();
            scene.add(mesh);
            remotePlayers[conn.peer] = { mesh, health: 100 };
            updatePlayerList();
          }
          const rp = remotePlayers[conn.peer];
          rp.mesh.position.set(data.x, 1, data.z);
          if (data.rotationY !== undefined) rp.mesh.rotation.y = data.rotationY;
        }
        else if (data.type === 'hit' && !isDead) {
          health -= 25;
          if (health <= 0) dieAndRespawn();
        }
        else if (data.type === 'chat') addChatMessage(conn.peer, data.message);
      });
      conn.on('close', () => {
        if (remotePlayers[conn.peer]) {
          scene.remove(remotePlayers[conn.peer].mesh);
          delete remotePlayers[conn.peer];
          updatePlayerList();
        }
        delete connections[conn.peer];
      });
    }

    function startPeerAsHost() {
      peer = new Peer(ROOM_ID, { debug: 1 });
      peer.on('open', () => { statusDisplay.textContent = "Connected as Host"; isHost = true; });
      peer.on('connection', setupConnection);
      peer.on('error', e => { if (e.type === 'unavailable-id') startPeerAsClient(); });
    }

    function startPeerAsClient() {
      peer = new Peer({ debug: 1 });
      peer.on('open', () => {
        statusDisplay.textContent = "Connected as Client";
        const conn = peer.connect(ROOM_ID);
        conn.on('open', () => setupConnection(conn));
      });
    }

    startPeerAsHost();

    function sendChatMessage(msg) {
      addChatMessage("You", msg);
      for (let id in connections) if (connections[id].open)
        connections[id].send({ type: 'chat', message: msg });
    }

    const bullets = [];
    function spawnBullet() {
      const b = new THREE.Mesh(new THREE.SphereGeometry(0.1), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
      b.position.copy(camera.position);
      b.direction = camera.getWorldDirection(new THREE.Vector3()).clone();
      scene.add(b);
      bullets.push(b);
    }

    document.addEventListener('click', () => {
      if (!isDead && chatInput.style.display === "none") spawnBullet();
    });

    function checkBulletHit(b) {
      for (let id in remotePlayers) {
        const p = remotePlayers[id];
        if (b.position.distanceTo(p.mesh.position) < 1.5) {
          connections[id]?.send({ type: 'hit' });
          return true;
        }
      }
      return false;
    }

    function dieAndRespawn() {
      isDead = true;
      health = 0;
      healthDisplay.textContent = "DEAD";
      controls.getObject().position.set(999,999,999);
      setTimeout(() => {
        isDead = false;
        health = 100;
        healthDisplay.textContent = health;
        controls.getObject().position.set(Math.random()*20-10, 1.6, Math.random()*20-10);
      }, 3000);
    }

    let mods = { esp: false, tracers: false, aimbot: false, triggerbot: false };
    const modMenu = document.createElement('div');
    modMenu.style.position = 'absolute';
    modMenu.style.top = '50px';
    modMenu.style.left = '50px';
    modMenu.style.background = 'rgba(0,0,0,0.8)';
    modMenu.style.color = 'white';
    modMenu.style.padding = '10px';
    modMenu.style.border = '2px solid white';
    modMenu.style.borderRadius = '8px';
    modMenu.style.display = 'none';
    modMenu.style.zIndex = '99';
    modMenu.innerHTML = `
      <strong>Mod Menu</strong><br>
      <label><input type="checkbox" id="espToggle"> ESP</label><br>
      <label><input type="checkbox" id="tracersToggle"> Tracers</label><br>
      <label><input type="checkbox" id="aimbotToggle"> Aimbot</label><br>
      <label><input type="checkbox" id="triggerbotToggle"> Triggerbot</label>
    `;
    document.body.appendChild(modMenu);
    ['esp','tracers','aimbot','triggerbot'].forEach(name => {
      document.getElementById(name + 'Toggle').onchange = e => mods[name] = e.target.checked;
    });

    document.addEventListener('keydown', e => {
      if (e.key === ';') modMenu.style.display = modMenu.style.display === 'none' ? 'block' : 'none';
    });

    const tracerLines = [];
    const espBoxes = [];
    function clearHelpers() {
      tracerLines.forEach(l => scene.remove(l));
      espBoxes.forEach(b => scene.remove(b));
      tracerLines.length = espBoxes.length = 0;
    }

    function updateESPAndTracers() {
      clearHelpers();
      const eye = controls.getObject().position.clone().add(new THREE.Vector3(0,1.6,0));
      for (let id in remotePlayers) {
        const enemy = remotePlayers[id];
        if (mods.esp) {
          const bh = new THREE.BoxHelper(enemy.mesh);
          bh.material.color.set(0x00ff00);
          bh.material.depthTest = false;
          bh.renderOrder = 999;
          espBoxes.push(bh);
          scene.add(bh);
        }
        if (mods.tracers) {
          const end = enemy.mesh.position.clone().add(new THREE.Vector3(0,1,0));
          const geo = new THREE.BufferGeometry().setFromPoints([eye, end]);
          const mat = new THREE.LineBasicMaterial({ color:0xff0000, depthTest:false });
          const line = new THREE.Line(geo, mat);
          line.renderOrder = 998;
          scene.add(line);
          tracerLines.push(line);
        }
      }
    }

    let isAiming = false;
    document.addEventListener('mousedown', e => { if (e.button===2) isAiming = true });
    document.addEventListener('mouseup',   e => { if (e.button===2) isAiming = false });

    const lookSpeed = 0.05, moveSpeed = 0.2;
    let gamepadConnected = false, shootCooldown = 0, triggerbotCooldown = 0, velocityY = 0;
    let isJumping = false;
    const velocity = new THREE.Vector3();

    window.addEventListener("gamepadconnected", () => gamepadConnected = true);
    window.addEventListener("gamepaddisconnected", () => gamepadConnected = false);

    function applyGamepadLook(gp) {
      const rx = gp.axes[2];
      const ry = gp.axes[3];
      const dead = 0.15;
      const dx = Math.abs(rx) > dead ? rx : 0;
      const dy = Math.abs(ry) > dead ? ry : 0;
      controls.getObject().rotation.y -= dx * lookSpeed;
      camera.rotation.x -= dy * lookSpeed;
      camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
    }

    function animate() {
      requestAnimationFrame(animate);
      const gp = gamepadConnected ? navigator.getGamepads()[0] : null;

      if (!isDead && chatInput.style.display === 'none') {
        velocity.set(0,0,0);
        if (keys.KeyW) velocity.z -= 1;
        if (keys.KeyS) velocity.z += 1;
        if (keys.KeyA) velocity.x -= 1;
        if (keys.KeyD) velocity.x += 1;

        if (gp) {
          const lx = gp.axes[0], ly = gp.axes[1];
          const dead = 0.15;
          const dx = Math.abs(lx)>dead?lx:0;
          const dy = Math.abs(ly)>dead?ly:0;
          if (dx || dy) {
            velocity.x += dx;
            velocity.z += dy;
          }
          applyGamepadLook(gp);
          if ((keys.Space || gp.buttons[0].pressed) && !isJumping) {
            velocityY = 0.2; isJumping = true;
          }
          if (gp.buttons[7].pressed && shootCooldown===0) {
            spawnBullet(); shootCooldown = 15;
          }
        }
        velocity.normalize().applyQuaternion(camera.quaternion);
        velocity.y = 0;
        const next = controls.getObject().position.clone().add(velocity.multiplyScalar(moveSpeed));
        velocityY -= 0.01;
        next.y += velocityY;
        if (next.y<=1.6) { next.y=1.6; velocityY =0; isJumping = false; }
        if (!collides(next)) controls.getObject().position.copy(next);

        for (let id in connections) {
          const conn = connections[id];
          if (conn.open) {
            const p = controls.getObject().position;
            conn.send({ type:'position', x:p.x, y:p.y, z:p.z, rotationY: controls.getObject().rotation.y });
          }
        }
      }

      bullets.forEach((b,i) => {
        b.position.add(b.direction.clone().multiplyScalar(0.5));
        if (checkBulletHit(b)) { scene.remove(b); bullets.splice(i,1); }
        else if (b.position.length()>200) { scene.remove(b); bullets.splice(i,1); }
      });

      updateESPAndTracers();

      if (mods.aimbot && isAiming) {
        let closest = null, min = Infinity;
        Object.values(remotePlayers).forEach(rp => {
          const d = camera.position.distanceTo(rp.mesh.position);
          if (d < min) { min = d; closest = rp; }
        });
        if (closest) {
          const tgt = closest.mesh.position.clone().add(new THREE.Vector3(0,1,0));
          const dir = tgt.sub(camera.position).normalize();
          const tq = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,-1), dir);
          camera.quaternion.slerp(tq, 0.2);
          controls.getObject().quaternion.copy(camera.quaternion);
        }
      }

      if (mods.triggerbot && !isDead) {
        let closest = null, min=Infinity;
        Object.values(remotePlayers).forEach(rp => {
          const d = camera.position.distanceTo(rp.mesh.position);
          if (d < min) { min = d; closest = rp; }
        });
        if (closest) {
          const pos = closest.mesh.position.clone().add(new THREE.Vector3(0,1,0));
          const vec = pos.project(camera);
          if (Math.abs(vec.x)<0.05 && Math.abs(vec.y)<0.05 && triggerbotCooldown===0) {
            spawnBullet(); triggerbotCooldown = 20;
          }
        }
      }

      if (shootCooldown) shootCooldown--;
      if (triggerbotCooldown) triggerbotCooldown--;

      renderer.render(scene, camera);
      healthDisplay.textContent = isDead ? "DEAD" : health;
    }

    animate();
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
